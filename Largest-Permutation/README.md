# Largest Permutation
原题见[这里](https://www.hackerrank.com/challenges/largest-permutation/problem)

给定一个长度为n的数组，数组的元素由1到n的正整数构成且没有重复，元素是随机打乱的。

你只可以做一种操作，就是其中的任意两个元素位置。最多操作k次。问能够生成的最大字典序数组是多少。

对于两个不同数组，比较它们的字典序大小，是从第0个元素开始，到第n-1个元素为止，从前往后，依次比较各位置元素大小，碰到第一个元素值不相等的位置，哪个数组对应的元素大，则字典序更大。

例如，对于[2, 1, 3, 4]和[3, 1, 2, 4]，则后者字典序大，因为第0个位置就已经分出了大小, 3 > 2。

对于[2, 1, 4, 3]和[2, 1, 3, 4]，前者字典序大。第0个和第1个位置元素都相等，而第2个位置分出了大小，4 > 3。

# 分析
先抛开k次的限制，单纯让生成的字典序尽可能大，要怎么做呢？

当然是，让n作为第0个元素，让n-1作为第1个元素，n-2作为第2个元素，依次类推。

如果只有一次交换的机会呢，当然是，优先把n换到第0个位置吧。有2次机会呢？先换n，再换n-1。

所以，就是这样的贪心法，将数组从头到尾进行遍历，检查第i个元素的值是不是n - i，若不是，则消耗一次交换机会将其换过来，直到没有交换机会或遍历完为止。

具体代码见[solve.php](./solve.php)