# Knapsack
原题见[这里](https://www.hackerrank.com/challenges/unbounded-knapsack/problem)

给定一个正整数数组和一个目标sum，问使用数组中的元素求和，能够达到的小于等于sum的最大值是多少，数组中每个元素可以使用任意多次。

# 分析
看到题目，你会不会想到什么，例如，给定一个背包，容积为sum，有n件物品可以往里放:)

是的，就是背包问题了，自然是用动态规划。

我第一反应是使用二维数组的解法，然后才会想到压缩空间使用一维数组的解法。

## 二维数组解法
令dp[i][j]表示对于容积为j的背包，只取0到i的物品，能够填充的最大容积。

假设物品i占据的容积为c[i]，则dp[i][j]等于如下两者的最大值：
* c[i] + dp[i][j - c[i]]，若j >= c[i]。意思是放一个物品i进入，然后继续从0到i的物品中取。
* dp[i-1][j]。跳过物品i，从从0到i-1的物品中取。

初始对于 i = 0, 1, 2...sum, dp[0][i] = i - i % c[0], 即对每个容积， 只取序号为0的物品，能够填充的容积
若n为数组长度，则dp[n-1][sum]就是最终结果

具体代码见[solve-2d.php](./solve-2d.php)

## 一维数组的解法
一维数组的解法， 主要是针对容积来进行从小到大的遍历。

假设dp[i]表示容积为i的背包，能够填充的最大容积，那么怎么迭代呢？

当然是，随便放一个容积为t的物品，然后求dp[i-t]，也就是说：
* dp[i] = max(c[j] + dp[i - c[j]])(j = 0, 1, 2, ... n)

初始dp[0] = 0, 这样依次迭代求出dp[1],dp[2]，... dp[sum]即可。

具体代码见[solve.php](./solve.php)