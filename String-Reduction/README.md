# String Reduction
原题见[这里](https://www.hackerrank.com/challenges/string-reduction/problem)

给定一个仅由a,b,c三种字母组成的字符串，仅能做如下一种操作：
* 选择相邻的两个不同字母，然后用第三种字母替换它。例如，将ab替换成c，将ca替换成b，等等。

不断的做此操作，直到无法再操作为止。

问，对于给定的字符串，最终能够形成的最短字符串长度是多少。

# 分析
这道题，看着分类分到了动态规划，但其实是数学问题！

首先，最终生成的最短字符串，肯定只包含一种字符。不然，总有两个不同的字符是相邻的，它们俩可以继续替换。

所以，如果一开始初始字符串就只包含一种字符，那就是个黑洞，根本没法操作一郎，直接返回它的长度就好。

那么，如果能够进行替换操作呢？答案是，生成的最短字符串，长度绝对不会超过2。下面就来证明它。

假设最终生成的最短字符串只包含a，数量为t, t > 2。由于至少有一次消去操作，那么，这t个a中肯定至少有一个是由bc或cb替换而来。

假设是bc替换而来的好了，下面的做法对cb也适用。那么，现在把这一个a还原，其他a的不变，字符串可能有三种情况（其实是一种，强行分类）：
* bc开头，后面t - 1个a，即bcaaaaa.....aaaa
* bc在中间，即 aaa....aaabcaaa...aaa
* bc结尾，前面t - 1个a，即aaa...aaabc

对于第一种情况，如果我们换一种替换方法呢？即不进行bc -> a的替换，而是让ca -> b，就会变成bbaaaa...aaa，然后，注意到什么没有？是的，又可以继续ba->c，成为bcaaa.aaa，如此反复，最终a会被全部消除掉。
然后最终要么是bc, 要么是bb，而bc -> a，所以最终可以形成长度小于等于2的字符串，明显比t更小！

第三种情况，跟上面的一样，不断的ab -> c，然后ac -> b，左边的会被全部消除掉。

第二种情况，其实还是一样，用b往左消，用c往右消。

所以，只要能够进行一次替换，则一定可以最终变成长度小于等于2的字符串。

那么，有没有可能通过某种方式，令最终一定变成长度为1的字符串呢？非常遗憾，答案是不能。这就是下面要讲的另一个关于奇偶的性质，这个性质讲完，算法也就出来了。

所谓的奇偶，指的是当前字符串中a,b,c的数量的奇偶，那么它们有什么约束呢？约束出在它们的变化方式上。

替换的过程是，将两种字符替换成第三种字符，也就是说，前两者的数量减1，第三种字符数量加1，也就是说，这三种字符的奇偶性是同时发生变化的。

那么，来穷举一下好了，初始状态下，三种字符的奇偶情况：
* 3奇
* 2奇1偶
* 1奇2偶
* 3偶

然后既然每次都同时发生变化，那么，能够互相转化的集合是这样的：
* 3奇 <-> 3偶。 一开始三种数量都是奇数，那么，做一次消除，则数量都变为偶数，再做，则又都变为奇数，如此反复。
* 1奇2偶 <-> 2奇1偶。 跟上面的情况是一样的，也是来回反复。

所以最终长度为2的字符串，没法变成长度为1的字符串，因为前者三种数量都是偶数（0，0，2），而后者是2偶1奇(0, 0, 1)，这两者是无法互相转化的。

而有了这一条性质，最后结论也出来了：
* 如果初始字符串只包含一种字符，则最终能生成的最短字符串就是该字符串长度。
* 否则：
    * 如果初始字符串中三种字符的数量都为奇数或都为偶数，则最终生成最短字符串长度为2.
    * 其他情况，最终生成最短字符串长度为1.

就依次遍历，统计各字符次数，按上面的处理方式返回就好。

最终代码很简单，但是推导过程不容易，果然还是要好好学数学啊。

具体代码见[solve.php](./solve.php)