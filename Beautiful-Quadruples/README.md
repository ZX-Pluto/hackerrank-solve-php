# Beautiful Quadruples
原题见[这里](https://www.hackerrank.com/challenges/xor-quadruples/problem)

给定一个四元组(w, x, y, z)，如果它们满足以下条件，则称这个四元组是优美(我胡乱翻译的，可以理解为就是满足条件就好)的:
* w ^ x ^ y ^ z != 0，其中 ^ 就是异或操作

下面，给定四个数A,B,C,D，计算满足以下限制的优美四元组的个数：
* 1 <= w <= A
* 1 <= x <= B
* 1 <= y <= C
* 1 <= z <= D

注意，两个四元组会被当作同一个，如果它们满足以下性质：
* 四元组中出现的所有数字及出现的次数均相同

例如， (1, 2, 2, 3)和(3, 2, 1, 2)就是相同的， (1, 1, 1, 4)和(1, 4, 1, 1)也是相同的

# 分析
首先来解决四元组重复的问题， 如果我们取值的时候，能够做到w <= x <= y <= z，即后面的数不小于前面的，就不会有重复了，要做到这一点，只需要把给定的四个数先从小到大排序。

假设排序后的数组是arr，然后A对应arr[0], B对应arr[1], C对应arr[2]， D对应arr[3]，遍历时保持 w <= x <= y <= z， 同样的一个四元组只取一遍，这样就可以所有的组合都被取到，且没有重复。

然后，求结果的话，，第一反应就是，暴力穷取， 先求前三项的异或结果s， 假设此时第四项所有能取的值为t个，看这些值里有没有等于s的，有的话总结果数加上 t - 1（因为每个值在每轮遍历中只会出现一次）， 没有的话总结果数加上t。

但是，这样的话有点慢， 三层循环。那么， 两两组合，先求前两项的异或结果s，再在后两项的异或结果中查找满足条件的个数好了。

我的具体做法是这样的， 每次循环，假设前两项异或结果为r，第二项的值为j， 则（后两项满足条件的数量 = 第三项值大于等于j时后两项异或结果总数 - 第三项值大于等于j时后两项异或结果等于r总数）。

因此对后两项做一次遍历，求出这两个结果总数，再遍历前两项，处理对应结果即可。

具体代码见[solve.php](./solve.php)