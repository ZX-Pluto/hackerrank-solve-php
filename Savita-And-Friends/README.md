# Savita And Friends
原题见[这里](https://www.hackerrank.com/challenges/savita-and-friends/problem)

N个城市，M条路。即N个点，M条无向边，构成一个连通图。

需要在编号为K（编号从1开始）的边上选择一个点，使得从此点到所有点的最短路径中的最大距离最小。这个讲法有点绕，拆成两句话来说吧。
对于K上的每个点，都可以计算出它到所有城市的最短路径，然后得到所有这些路径中的最大值。现在需要做的事，找到一个点，使得计算出的最大值小于等于K上其他点计算出的最大值。

假设编号为K的边连接的是A和B，按题目给的顺序，A在前，B在后，输出此点离A的距离，同时输出对应的所有最短路径中的最大距离。
如果有多个解，输出离A更近的距离。

# 分析
这道题有种说不清楚的感觉，特别是第二部分，只是对着函数坐标图心里觉得“这样是可以得出最后答案的”，但要严格证明的话，无从下笔根本开始不了一郎。我努力尝试讲解吧:(

还是分成两步来考虑吧。

## 计算两端节点最短路径
首先，从K上选择一个点，则从其出发到所有点的最短路径，要么最先经过A，要么最先经过B。这个应该真的很显然了，要么往边的某一头走，要么往另一头走。

假设选择的这个点为Z，则，可以进一步推导出，Z到某个节点C的最短路径，要么是Z到A，然后加上A到C的最短路径，要么是Z到B，再加上B到C的最短路径，取两者的最小值。这个，大概也不需要证明吧。

所以第一步，就是求出A和B到所有节点的最短路径。这个，当然，是用迪克(杰)斯特拉算法。

本来我应该从头开始讲这个算法的，但是，但是我在另一道题里讲过了，就不再复制粘贴一遍了，见[这里](../Dijkstra-Reach2)

还是要提醒一句，实现的时候，对于找当前路径长度最小的一项时，用堆来处理。我不知道其他语言怎么样，我用的PHP，不用堆的话后面好几个Test Case都会超时。
至于堆，当然也不是自己从头实现，我用的是SplPriorityQueue，其他语言中应该也有类似自带的的数据结构吧，用它们。

## 找出使最短路径最大值最小的点
假设d(i, j)表示i与j节点的最短路径的长度，连接A和B的K的长度为c，有：
* 对于任意i, |d(a, i) - d(b, i)| <= c

即i到A的最短距离，与i到B的最短距离，两者相差不会超过K的长度。只需要证明d(a, i) >= d(b, i)的情况即可，反过来的情况可以同理得出。

假设 d(a, i) - d(b, i) > c，则 d(b, i) + c < d(a, i)， 也就是说，从i到b的最短距离，再加上走K到a，距离要比 i到a的最短距离还要短，这样就构成了一条更短的从i到a的路径，与d的定义矛盾。

设对于i节点来说，K上选择的点Z到A的距离为x时，对应的Z到i的最短路径为f(i, x)，根据上一步，取两种路径的最小值，有
* f(i, x) = min(x + d(a, i), c - x + d(b ,i))

则对于两种路径的大小，有如下两种情况：
1. x + d(a, i) <= c - x + d(b , i)， 此时有 x <= (c + d(b , i) - d(a, i))/2
2. 与1相反， x > (c + d(b , i) - d(a, i))/2

即可以看做一个分段函数，前半段单调递增，后半段单调递增。而当|d(a, i) - d(b, i)| = c时，会只有前半段或后半段。此函数可能的图形如下：

![前后段都有](./1.png)

![只有前段](./2.png)

![只有后段](./3.png)

如果将全部i对应的分段函数都画在同一个坐标系中，可能就是这样了。

![放一起](./4.png)

数学中一个重要的方法是什么呢？观察，发现规律，并进行证明。当然，对于提交而言，不需要证明，只要利用发现的规律提交结果通过了就行。但这里，我们还是要本着刨根问底拦不住的精神，证明它的正确性。

对于两个节点i，j来说，它们的分段函数可能有以下几种情况：
1. 前半段部分重合。
2. 后半段部分重合。
3. 完全没有交点。
4. i的前半段与j的后半段相交，或是i的后半段与j的前半段相交。

因为所有前半段斜率都是1，后半段斜率都是-1，即所有前半段平行，所有后半段也平行。因此如果没有重合的话，两个分段函数的交点只可能是一方的前半段与另一方的后半段相交。

现在仅考虑i与j的分段函数，使它们中的最大值最小的x取值，只可能是以下三者之一：
1. x = 0
2. x = c
3. x = i与i的分段函数交点的x坐标（如果一方前半段与另一方后半段相交）。

对于分段函数可能的位置情况来说，前3种其实都是“一者始终在另一都上方”，即对于所有x，都有f(i, x) >= f(j, x)，或是对于所有x，都有f(i, x) <= f(j, x)。
这样，由于前半段的起点和后半段的终点是两个极小值点，因此x=0或x=c时使得最大值最小。

对于最后一种相交的情况，首先，x=0和x=c依旧是两个极值点。

其次，假设是f(i, x)的前半段与f(j, x)的后半段相交（可以参考图中的f3和f4），交点对应的x取值为o，i的前半段终点对应的x值为p，j的前半段终点对应的x值为q。则有
* q <= o <= p。从图上看来，就是交点横坐标夹在两个顶点横坐标之间。

对于 0 <= x <= q的部分，即i和j都是前半段的部分，函数是单调递增的，因此，x=0时，在这部分内使得最大值最小。

对于 q <= x <= p的部分，即一方为前半段，另一方为后半段的部分，x = o在这部分内使得最大值最小，因为 q <= x <= o时， 有f(j ,x) >= f(j , o)，而当 o <= x <= p时， 有f(i, x) <= f(i , o)。

对于 p <= x <= c的部分，i和j都是后半段，函数单调递减，当然取x=c在这部分内使得最大值最小。

因此对于两个分段函数，只要求出这三者对应的分段函数最大值，再取其中的最小者就行了。

对于所有分段函数，可以将这个推广一下，满足条件的取值，是x =0或 x=c，或两个分段函数的交点。

要注意，在这里，我们计算时可以做一定的优化，不需要把所有分段函数的交点都计算出来。

计算的时候做一点点技巧，将分段函数按x = 0时（即起点）的值从大到小排序。一开始取前2个进行计算，然后每轮计算都按序取下一个。

假设对于前n个分段函数，已经找到了所有交点中的最小者。下面再加入第n+1个，设对应节点为l，对应的分段函数是f(l,x)。

首先，若f(l,x)跟当前已处理的分段函数有交点，则只可能是f(l,x)的前半段与之前某个分段函数的后半段相交。

而这一步计算，只需要求f(l, x)跟之前分段函数中后半段在最上方的一个,假设是t，与t的交点即可。下面来证明这一点。分两种情况：
1. 与t没有交点。则由于t是后半段在最上方的一个，则l始终在t下方，x取任何值时，f(t,x) >= f(l, x)，无需再考虑l。
2. 与t有交点。则需要证明其他交点要么对应的取值比此交点大，要么比当前已经求得的交点大。

对于情况一，已经说了无需考虑。

对于情况二，假设此交点对应x = pt。则对于其他任一交点x = pi，对应的f(i, x)，都有 pi <= pt。
* 若f(i, x)与f(t, x)没有交点，则由于t在i上方，因此f(i, x)无需再考虑，考虑f(t, x)即可。
* 若f(i, x)与f(t, x)有交点，对应x = pti，则 pti <= pi。设t前半段终点 x = et, 有pti <= et <= pt。 若 pi <= et，则对应最大值比 x = pti要大，若 pi >= et，则对应最大值为 x = pt要大。

这样也就得出了迭代计算的方法。
1. 将所有分段函数按起点值从大到小排序。
2. 初始化终点最大（即后半段在最上方）项为第一项，初始化"最大值最小者"为第一项起点值（即x = 0时的最短路径最大值）
3. 从第二项开始，对于每一项，做如下操作：
    * 如果与当前终点最大项没有交点，跳过。
    * 如果与当前终点最大项有交点。
        * 计算此交点x坐标及对应路径长度，如果比当前"最大值最小者"要小，替换。
        * 将当前终点最大项设为此项
4. 求当前终点最大项x=c时对应的值（即x = c时的最短路径最大值），再与当前“最大值最小者”比较，更小的话则替换

最终输出求出的x坐标及对应路径长度即可。

具体代码见[solve.php](./solve.php)