# Find Digits
原题见[这里](https://www.hackerrank.com/challenges/minimum-loss/problem)
对于一个数组， 若一对元素a, b满足条件，则有:
1. a在数组中位置在b之前。
2. a > b
要求在所有满足条件的元素对中，找到a - b的值是最小的一对。最后输出 a - b的值

# 分析
第一反应就是直接遍历，对于每个元素，拿它之后的所有元素与它作比较判断。这样肯定是可以求出正确结果的，但是，会超时。  
首先我想了下最理想容易处理的情况，整个原始数组就是从大到小排列的， 这时候只要比较相邻的两个元素就好。  
然后，在拿题目给的例子试验时， 我不小心发现（有的时候真的这种发现很重要），对于最终选定的两个元素， 如果将原数组排序，则它们在排序后数组中是相邻的。  
这是偶然么？不，是必然的，下面来证明它。  
  
假设a和b就是最终选定的两个元素, 令index(i)表示元素i在原数组中的位置，则有 a > b 且 index(a) < index(b)。  
现在假设a和b在排序后的数组中不是相邻的，也就是说，存在元素c，使得 a > c > b。  
而c的位置只可能有两种情况，要么 index(c) > index(a), 要么 index(c) < index(a)。  
若 index(c) < index(a)， 有 index(c) < index(b) ，同时 0 < c - b < a - b。 则根据题意， c 和 b满足条件，且比 a - b更小，与a - b是满足条件的最小元素对矛盾。  
若 index(c) > index(a)， 则类似的， 可以得出， a和c满足条件，且a - c比 a - b更小，矛盾。
  
因此可以得出算法步骤：
1. 设置当前最小值为无穷大。
2. 对原数组从大到小排序。
3. 对于排序后的数组， 依次检查相邻的两个元素a和b， 如果它们在原数组中a也在b之前出现， 则令 a - b与当前最小值比较，取更小者。
4. 输出当前最小值。

具体代码见[solve.php](./solve.php)