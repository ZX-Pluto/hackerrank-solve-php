# Jim and his LAN Party
原题见[这里](https://www.hackerrank.com/challenges/jim-and-his-lan-party/problem)

有中文, 就不用翻译了.

# 分析

我的第一反应是, 如果对每根线遍历, 将对应连接的两个网络合并成一个新的网络, 再判断是否有哪个组第一次所有人都在这个新的网络，会不会跑起来太慢了？

答案是，其实并不会！

我这一次真的是有点畏首畏尾了，一上来就想着会超时，但实际上，解题的过程就应该是，先有一个最基本的不那么好的解法，确保正确的情况下，再考虑进一步的优化。

维护每个人当前所在的网络，使用的数据结构是并查集，实际就是一个parent数组，表示每个节点的父节点，父节点是自己的，就是当前网络的根，具体的并查集说明见[这里](https://www.geeksforgeeks.org/disjoint-set-data-structures)

算法的原理上面已经讲了，这里再详细一点说明好了：
1. 初始化记录每个组的人数，初始化答案answer数组所有值为-1，人数为1的组，对应answer设置为0（按题意）.
2. 初始化parent数组，将每个人的parent指向自己，表示现在每个人是一个独立的网络。初始化每个网络root对应的各组成员计数。
3. 针对每一条线，假设是第i条，连接的两个人是u和v，则：
    1. 找到u对应的网络根节点rootu，u对应的网络根节点rootv。如果rootu = rootv，说明已经在同一个网络，不做处理，否则转2.
    2. 选择rootu和rootv中包含组别较少的，将其并入另一个网络，假设是rootu，则设置parent[rootu] = rootv， 将rootu对应的组成员计数累加到rootv对应的计数中去，如果有某个组第一次达到满员，则设置对应answer为i。

具体代码见[solve-brute.php](./solve-brute.php)

后来看了编辑给的答案，觉得也挺有意思，用的是二分查找的办法，即对每个组，二分查找得出每个组第一次满员对应的连接index，判断的方式其实也挺简单粗暴的，直接检查一个组内所有人对应的局域网root。

我也尝试这样写了下，具体代码见[solve.php](./solve.php)