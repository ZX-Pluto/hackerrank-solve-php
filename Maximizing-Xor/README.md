# Maximizing XOR
原题见[这里](https://www.hackerrank.com/challenges/maximizing-xor/problem)

有中文，而且已经很简单明了了，给定的两个整数L <= R，对于任意的A，B，满足 L <= A <= B <= R， 输出A xor B的最大值。

# 分析
简单的题目嘛，通常没有超时的限制的，所以，第一个方法，就是莽，计算L到R区间内任意两个整数的异或值，输出最大的即可。

但是，这不是一个比较好的解法，没错，要用数学知识，要优雅，要更低的时间复杂度。

考虑L和R用二进制数表示，并在L前面补0补至与R位数相同。

如果最高位不同，即L最高位为0，R最高位为1（反过来是不可能的，因为L <= R，R的最高位必须 >= L的最高位），那么能够组成的异或最大值就是从此位开始，到最低位为止，所有位都是1的二进制数对应的值。

为什么呢？假设一共有i位，则L和R可以写成如下形式：
* L = 0xxxxxxxxx(x表示任意0或1，共i-1个x)
* R = 1xxxxxxxxx(x表示任意0或1，共i-1个x)

那么，就可以取 A = 011111111(0后面跟i-1个1), B = 1000000000(1后面跟i-1个0)，这样是满足 L <= A <= B <= R的条件的，因为L最大也只可能等于A，同样的，R最小也只可能等于B。

这样异或得到的值就是i个1组成的二进制数了。

同时，也不可能得到比这更大的数了，因为总共就i位，异或操作不是相加，不会有进位的。

如果最高位相同，那么，无论A和B怎么取，最高位异或结果都只可能是0，于是最高位就可以抛弃了，将L和R最高位变成0，得到新的L'和R'

然后，对于L'和R'，咦？感觉又回到了同样的问题，可以用它们最高位是否相同进行判断了，不相同，则结果是（i-1）个1组成的二进制数，相同的话，再去掉最高位继续。

如此反复。

所以就是要找到最高的L和R值不不同的位。这个就，先直接用 L xor R，再对得到的值进行检查就好了。

具体代码见[solve.php](./solve.php)