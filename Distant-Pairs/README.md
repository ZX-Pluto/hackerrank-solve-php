# Distant Pairs
原题见[这里](https://www.hackerrank.com/challenges/distant-pairs/problem)

有一条长度为c的线段，线段上单个点的坐标为0到c-1的正整数。

现在把它绕成一个环，定义两个点之间的距离就是从一个点沿着环到另一个点的最短距离，即假设两个点坐标分别是a和b，那么它们之间的距离就是min(|a-b|, c - |a-b|)。

现在，将距离扩展到点对，一个点对就是由两个点组成，比如[a1, b1]和[a2, b2]，而两个点对之间的距离，就是它们包含的四个点，任意两两组合，求出的点之间的距离的最小值。

即假设对于两个点， d(a, b) = min(|a-b|, c - |a-b|)，那么两个点对之间的距离dis定义为：
* dis([a1, b1], [a2, b2]) = min(d(a1, b1), d(a1, a2), d(a1, b2), d(b1, a2), d(b1, b2), d(a2, b2))

现在，给定c和一系列点对，要求找到所有不同点对之间的距离的最大值。

# 分析
难题有两种，一种是你完全不知道怎么下手，另一种是你有办法，但是它不够快。

此题属于后一种。比较显然，最简单粗暴的办法，两两比较计算距离，最后输出最大值，而且，也很显然，这不够快。

这道题被分在了“查询”类别中，查询什么呢，当然是，求什么，就查什么。

现在要求距离最大值，那就查，某个距离是否有点对能够达到，使用二分查找，找到能达到跟不能达到的边界，最大值就出来了。

下面先来考虑下对于某个距离r，如果两个点之间的距离大于等于r，需要满足什么条件。

假设两个点对[a1, b1]和[a2, b2]， a1 < b1, a2 < b2, a1 < a2。即在组点对的时候，将小值放前面。

首先必须有：
* a1 + r <= b1
* a2 + r <= b2
* a1 + r <= a1

然后，再判断剩下的三种组合。

所以，如果对于[a2, b2]，要找是否存在满足条件的点对，可以先将满足上述条件的点对记录下来，然后再在其中检查以下三种情况之一的点[a1, b1]是否存在：
* b1 + r <= a2， 且 b2 + r <= c + a1，对应的情况是该点对的大值点比a2要小。
* a2 + r <= b1 <= b2 - r，且 b2 + r <= c + a1，对应的情况是该点对的大值点比a2要大，比b2要小。
* b2 + r <= b1， 且 b2 + r <= c + a1， 对应的情况是该点对的大值点比b2更大。

为了更快速的检查，而不是一个个比较，在这里需要巧妙的用线段树保存点对的信息。线段树之前有过说明，[见这里](../Quadrant-Queries)。

具体的作法是，对于满足条件的点对[a1, b1]，线段树对应的原始值为"大值对应的小值"，即ori[b1] = a1，如果有多个点对的大值为b1，则只保存小值中最大的那个。

这是因为，对于小值，唯一需要做检查的就是 b2 + r <= c + a1，即与b2的大值之间的距离是否满足条件，而且是覆盖坐标0方向的距离，因此小值越大越好。

使用线段树，保存的信息就成为了“某段范围内的大值对应的小值中的最大者”，只要能够找到，并且满足上述小值检查的条件，则说明有点对能够达到距离r。

具体代码见[solve.php](./solve.php)