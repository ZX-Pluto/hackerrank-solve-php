# Sherlock and Cost
原题见[这里](https://www.hackerrank.com/challenges/sherlock-and-cost/problem)

给定数组B，需要你构建如下条件的数组A：
* A与B长度相同。
* 对于任意位置i，有 1 <= A[i] <= B[i]，即必须是不大于B中对应位置数字的正整数。
* 使得A中每两个相邻位置数字之差的绝对值之和S最小。

上面的话可能有点绕，假设数组长度为n，则S可以写成这样：
* S = |A[1] - A[0]| + |A[2] - A[1]| + |A[3] - A[2]| + ... + |A[n-2] - A[n-3]| + |A[n-1] - A[b-2]| 

输出最终满足条件的S的值。

# 分析
先把问题转化一下，假设只处理前i个位置，令
* s[i] = |A[1] - A[0]| + |A[2] - A[1]| + |A[3] - A[2]| + ... + |A[i-2] - A[i-3]| + |A[i-1] - A[i-2]|

则对于前i个位置的s[i]的最大值，则对于任意位置j < i，A[j]要么为1，要么为B[j]。

先来证明最后一个位置i-1必须选1或B[i-1]。

假设不是这两者，则对于A[i-2]和A[i-1]对s[i]的贡献而言：
* 若A[i-1] > A[i-2]，则若A[i-1]选B[i-1]，能够做出更大的贡献。
* 同样的，若A[i-1] < A[i-2]，则若A[i-1]选1，能够做出更大的贡献。

而对于倒数第二个位置i-2而言，假设选的不是1或B[i-2]考虑与前后两个位置的大小关系：
* A[i-2] > A[i-3], A[i-2] > A[i-1]，则若A[i-2]取B[i-2]，能够做出更大的贡献。
* A[i-2] < A[i-3], A[i-2] < A[i-1]，则若A[i-2]取1，能够做出更大的贡献。
* A[i-2] > A[i-3], A[i-2] < A[i-1]，则不断将A[i-2]的值减少1，在A[i-2] = A[i-3]之前，贡献值都不变，再继续减少，就变成了第二种情况，能够做出更大的贡献。。
同样的，若不断将A[i-2]的值增加1，也可能做出更大的贡献。最坏的情况，也至少不会减少贡献。
* A[i-2] < A[i-3], A[i-2] > A[i-1]，同情况三类似。

所以，A[i-2]取1或B[i-2]时，才能使达到最终结果达到最大值。

依此类推，所有的位置j都必须选1或B[j]。

因此，用两个数组minArr和maxArr，分别记录位置j取1时，前j+1项能够达到的最大值，和位置j取B[j]时，前j+1项能够达到的最大值。

然后从前往后穷举递推即可。最后取minArr[n-1]和maxArr[n-1]中的更大者即可。

代码见[solve.php](./solve.php)