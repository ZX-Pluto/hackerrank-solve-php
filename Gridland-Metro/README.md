# Gridland Metro
原题见[这里](https://www.hackerrank.com/challenges/gridland-metro/problem)

一个城市，划分n*m个格，行编号从1到n，列编号从1到m。

这个城市有个奇怪的特点，火车只能在同一行上面开， 例如一趟火车起点和终点分别是(r,c1)和(r,c2)，表示该火车在第r行上运行，从第c1列开到第c2列，且c1<=c2。

现在，要在城市里建造灯柱，规则只有一条，不能建在有火车通过的格上。

现在，给定k个火车运行路线，需要求出最多能建造多少灯柱。

# 分析

既然火车只能在同一行上运行，那就针对每一行，求出空格（没有火车通过）数量，我的想法是，反过来求，求有火车通过的格子数量。

每一行， 最终格子的情况肯定是这样的：连续的空格和连续的非空格两者交替排列。

假设现在已经有了一段连续的非空格，再给一条火车运行轨道，那么，就拿这两段的起点和终点比，看两者是否能合并成更大的一段连续非空格。

问题在于，可能现在有多段连续的非空格，然后合并时每一段都要比较一遍，那么，有没有办法，每次合并比较时，只需要比较一段呢。

当然，是有的，处理的时候，按照轨道的起点排序之后再依次处理，这样，每次合并时，只要跟当前多段连续非空格的最后一段进行比较即可。

因为是按起点排序的，比较时，新的轨道起点一定大于等于最后一段非空格的起点，也就不再需要跟之前的比了（之前的终点一定在最后一段的起点之前）。

我这里的处理方式是，只保留最后一段非空格，新的轨道比较时，如果能合并，则更新最后一段非空格的终点，如果不能合并，则更新当前非空格总数量，同时设置新的轨道为最后一段非空格。

具体代码见[solve.php](./solve.php)