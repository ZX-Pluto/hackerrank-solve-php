# Travel around the world
原题见[这里](https://www.hackerrank.com/challenges/travel-around-the-world/problem)

有中文，就不翻译了。

# 分析
这道题一点也不中等，应该能分到困难级别里。

首先，肯定不会是暴力莽，每个开头走一圈，这样当然能得到正确答案，但是时间上通不过。

扫了眼上面，归入的类别是动态规划，那么怎么个规划呢，这个我想了很久很久很久，可能现在说出来你会觉得很简单，但是要一下子想出来，我还是做不到的。

假设A是一条能够从某个城市出发，然后游玩所有城市再回到出发点的路线，考虑一下将A划分成子段A[0],A[1],A[2]...A[t]。

其中每个子段都是“自给自足”的，也就是，在油箱为空的情况下从每个子段的第一个城市出发，都能够到达下一个子段的第一个城市。

显然这样的子段划分是一定存在的，最糟糕的情况，也就是不划分，整个A作为一个子段而已。

我们再对子段加一些限制条件，令子段必须为以下两者之一：
* 子段仅包含一个城市。
* 子段包含多个城市，除第一个城市外，从其他城市出发，都无法到达下一子段。

对于情况一，真的很显然，这个城市i必须满足 a[i] >= b[i].

对于情况二，考虑全局的情况，也只有此子段的首个城市有可能作为出发城市。

现在，如果我们不是针对路线A，而是针对所有城市，划分出了这样的子段，那么，有且仅有情况一的城市，和情况二的每个起点城市，可以作为出发城市成功环游。

首先，所有城市都必须归入一个子段。

其次，如果从某个城市开始，能够走到下个子段，它就一定能作为出发城市，因为每个子段都是自给自足的，从每个子段开始，就一定能继续到下一个。

相反的，如果走不到下个子段，当然就GG了。

这样，每个城市能不能作为出发城市，就可以确定了。

但是，上面说得天花乱坠，但每个子段要怎么求呢？

对于第二种子段，仔细观察，会发现，最后一个城市必须是耗油大于加油的。

那么，选择从一个耗油大于加油的城市开始，记录当前状态为缺XX升油，从其前一个城市开始，依次向前遍历。

假设当前处理城市为i，处理逻辑如下：
1. 若当前为不缺油状态。
    * 若此城市已处理过，退出
    * 若此城市耗油大于加油，设置为情况二最后一个城市，当前状态记录为缺（耗油-加油）升油。
    * 若此城市加油大于等于耗油，记录此城市为情况一城市，保持不缺油状态不变。
2. 若当前为缺油状态。
    * 若此城市耗油大于加油。
        * 若此城市等于当前情况二最后一个城市，说明转了一圈回来了，退出。
        * 否则，加入情况二城市，继续递推缺油数。
    * 若此城市加油大于等于耗油，对比当前缺油数。
        * 若能补满缺油数，则设为当前情况二的起始城市。
        * 若不能补上，加入情况二城市，继续递推缺油数。

这样，就能求出每个子段了，最后，再遍历一遍所有城市，数一遍情况一和情况二的总数，输出即可。

实际处理时，我还做了一些预处理的工作，例如调整加油量等。

具体代码见[solve.php](./solve.php)