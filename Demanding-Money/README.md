# Demanding Money
原题见[这里](https://www.hackerrank.com/challenges/borrowing-money/problem)

你们在打仗，敌方有N个房子，每个房子里都存有些矿，然后某些房子之间是有道路相连的。

这一天，你趁敌方英雄都出去了，打算偷他们一波矿。

你也是一个英雄，你的能力是瞬移，也就是说，你可以一瞬间到达任意房子，那些连接房子的道路不是给你走的，你偷完一个房子，可以马上去偷下一个房子。

但是，那些路也不是没有用的，它们也被赋予了特殊的能力，每当你拿走一个房子的矿时，与此房子通过1条路直接相连的房子中的矿，就会被立即转移到安全的地方，你就偷不到它们了。

现在给定各房子里的矿数和连接它们的道路，问：
1. 你最多能偷得多少矿？
2. 有多少种不同的方式能够偷到这么多矿？所谓的一种方式，指的是你成功偷取的房子集合，如果两种方式，对应的房子集合不同，则算不同的方式。

# 分析
这道题，我的想法就是，莽！

每个房子，要么偷，要么不偷，按这个方式莽！

当然，每个房子能不能偷是有限制的，会根据之前房子的偷取情况发生变化，因此，定义d(i, mask)表示在mask的限制下，选择 >= i的房子进行偷取，最多能偷得的矿，以及对应的偷取方式。

假设money[i]表示房子i中的矿量，令mask[i]为1表示此房子不可偷取，mask[i]为0表示此房子可偷取。则对 d(i, mask)处理如下：
1. 如果 i == N，即最后一个房子。
    * 如果mask[i] = 1， 返回[0, 1]，即偷不到矿，只有1种方式（不偷）。
    * 如果mask[i] = 0。则：
        * 若money[i] > 0， 返回[money[i], 1]，能偷，当然是偷才能拿到更多矿啊。
        * 若money[i] = 0， 返回[0 , 2]，注意，因为这房子矿为0，因此偷与不偷，拿到的矿都是0，但是！但是！但是！它们是两种不同的方式。
2. 否则，即 i < N。
    * 如果mask[i] = 1， 返回d(i+1, mask), 即没法偷，只好跳过。
    * 如果mask[i] = 0, 自然是要比较两种方案了，偷此房子 vs 不偷此房子。
        * 偷此房子，通过mask算出新的标志newMask, 得到结果 temp1 = d(i+1, newMask), 然后temp1[0] += money[i]
        * 不偷此房子，得到temp2 = d(i+1, mask)
        * 比较temp1和temp2
            * 若temp1[0] > temp2[0]， 返回temp1
            * 若temp2[0] > temp1[0]， 返回temp2
            * 返回[temp1[0], temp1[1] + temp2[1]]

在实际处理的过程中有一点稍微的优化，即当mask[i] = 0, money[i] > 0， 且偷i不会再影响后面的房子时，直接选择偷i，不需要再与不偷i的情况进行比较了。

具体代码见[solve.php](./solve.php)