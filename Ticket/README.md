# Ticket
原题见[这里](https://www.hackerrank.com/challenges/ticket/problem)

n个人排队买票，所有能到的目的地一共有k个，每个人要去的地方都是k个之中的一个。

一共有m个卖票的窗口。所有人一开始排成一队，然后从头到尾依次选择自己要去的窗口。

对于每个窗口，维持这些人在原有队列中的先后关系不变。即如果两个人i和j，在原始队列中i在j之前，那么如果他们去了同一个窗口，则i依旧在j之前。

另外，对于每个窗口排队的人，如果某个人j跟前面一个人i要去的目的地相同，则j可以买到打折票，票价是原始票价的80%。

现在，给定n个人要去的目的地，每个目的地的票价，以及m，问所有人买票的最小总花费是多少。

# 分析
这是一个图的问题，解法说明白了我能理解，但是就是自己一下子想不到，没有那种“灵光一闪”得出答案的感觉。

## 网上搜到的答案
先是看了下[这篇文章](https://www.cnblogs.com/Enceladus/p/7098983.html)，作者的思路是对的，但是，既然写了文章，就应该好好详细解释一下，一句话带过就跟没讲一样，代码里更是什么注释也没有。

我努力思考和理解了下里面的意思，在这里解释下。

首先，需要把这个问题转化成一个最大流最小花费问题，当然原文中说的是二分图最大权匹配，其实是等效的。

考虑排队的情况，最直观的关系是什么？是一个人在队伍中紧跟着另一个人。那么，对于图，也这样反映。

但是这样的话，每个人看作一个点处理，是不够的，需要将其拆成两个点，左点和右点。一个人i的左点指向另一个人j的右点，就表示i与j在同一队列且j紧跟着i。

假设n个人，对应的左点分别是1到n，右点分别是n+1到2n，再加上两个点，起点0，终点2n+1，设起点为S，终点为T。

添加初始边如下：
* 对于所有左点i，添加一条S->i的边，容量为1，花费为0，同时添加反向边i->S，容量为0，花费为0。
* 对于所有右点j，添加一条j->T的边，容易为1，花费为0，同时添加反向边T->j，容量为0，花费为0。
* 对于任意两个人i和j，如果i<j，添加一条i -> n + j的边，即i的左点指向j的右点，容量为1，如果i与j去的目的地不同，则花费为0，否则花费为 -0.2 * 去相应目的地的花费。意思就是能够节省的钱。
同时添加对应n + j -> i的反向边，容量为0,如果i与j去的目的地不同，则花费为0，否则花费为 0.2 * 去相应目的地的花费。

然后，实际处理的时候，并不是完整的求出最大流最小花费，而是先找n-k轮最小费用增广路，并处理相关流量。

接下来再继续找最小费用增广路时，如果碰到找到的增广路费用大于等于0，就说明已经到头了，此时停止查找。当然，最终一共最多也就找n-1轮。

每轮找到增广路时，就根据路线，更新实际每个人排队的前后关系。最终，根据排队的前后关系，就可以得出每个队列完整的排队方式，按此进行输出即可。

至于最终花费，就是每个人的原价，再加上每轮增广得到的最小费用之和。

其中用到的找最小费用增广路的算法就是spfa算法，这个我真的不想讲了，主要就是使用队列不断更新每个点到起点的最小费用的过程，自己百度下吧。

具体代码见[solve-other.php](./solve-other.php)

## 出题者的答案
上面的做法当然是正确的，但是感觉像是一种“反向”的解法，而出题者给的，则是“正向”的解法。

同样是跑最小费用最大流，上面的做法，限流是在[n-k,n-1]区间，而这里，限流是在[1, k]区间内。

在这里，多用了一个中间点用于限流。

n个人，对应的左点是1到n，右点是n+1到2n，中间限流点S'=2n+1，起点S=0,终点T=2n+2。

这里建立的边关系与上面的不同了，这里是如果两个人i和j，i排在j之前，则i的右点指向j的左点。

具体初始边如下：
* 添加一条S->S'，容量为m，花费为0。它的反向边加不加没有意义，反正是回不来的。
* 对于所有左点i，添加一条S'->i的边，容量为1，花费为i要去的目的地的花费，同时添加反向边i->S，容量为0，花费为 -i要去的目的地的花费。
* 对于每个人，添加一条其左点到右点的边，即对于i，添加一条i->n+i的边，容量为1，花费为负无穷大，同时添加反向边n+i->i，容量为0，花费为正无穷大。
这条边的意思是“i排在了某一队”，而花费为负无穷大的意义，是为了保证每个人的这条边都一定会被选中，即每个人一定会排在某个队列中。
* 对于所有右点j，添加一条j->T的边，容易为1，花费为0，同时添加反向边T->j，容量为0，花费为0。
* 对于任意两个人i和j，如果i<j，添加一条i + n -> j的边，即i的右点指向j的左点，容量为1，如果i与j去的目的地不同，则花费为j要去的目的地花费，否则花费为 0.8 * j要去的目的地花费。
同时添加对应j -> n + i的反向边，容量为0,如果i与j去的目的地不同，则花费为-j要去的目的地花费，否则花费为 -0.8 * j要去的目的地花费。

找最小费用增广路的过程也类似，如果找不到增广路了，或是找到的增广路花费大于等于0，则停止。

跟上面的处理类似，记录实际每个人排队的前后关系，最后根据这个计算总费用，以及得到每个人的队列编号。

具体代码见[solve.php](./solve.php)