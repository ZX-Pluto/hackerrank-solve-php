# Favorite sequence
原题见[这里](https://www.hackerrank.com/challenges/favourite-sequence/problem)

这个本来就有中文翻译，我就不重复讲一遍要做啥了……

# 分析
有一个暗示不知道你有没有发现，这道题被归在“图论”分类，所以，把它当做图来处理吧。

所有出现的数，每个数作为一个节点。

对于给的每一个恶作剧后的数列，两个相邻的元素就代表有一条有向边从前一个节点指向后一个节点。

最终，要求的是所有节点的一个拓扑排序。

所谓一个拓扑排序，就是一系列节点的一个序列，使得在这个序列中，对于任意两个节点u和v，若存在一条u->v的有向边，则u必须出现在v之前。

输出一个拓扑排序的算法如下：
1. 初始化序列为空。
2. 在图中找一个入度为0的节点n，即不存在任何一条边指向n，将此节点加入序列末尾。
3. 在图中移除掉节点n，再移除掉以n为作为弧尾的边，并更新对应的弧头的入度，即对于任意节点t,若存在一条n->t的有向边，则移除掉这条边，同时t的入度减1。
4. 如果所有节点都被移除了，返回序列，否则转2继续处理。

在第2步的时候，入度为0的节点可能同时有多个，根据题意，此时我们选最小的那个即可。

可以用堆来完成这个功能，在PHP中用SplPriorityQueue即可。

具体代码见[solve.php](./solve.php)