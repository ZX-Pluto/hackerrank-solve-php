# Chocolate in Box
原题见[这里](https://www.hackerrank.com/challenges/chocolate-in-box/problem)

有中文，就不翻译了。

# 分析
这个就是典型的Grundy理论了，之前解某题时有讲过，见[这里](../Stones-Game)

首先，自然是算出各个容器的Nimber的异或值，假设为g。

如果g为0，那么，不好意思，根本赢不了一郎。

否则，就是要想办法从某个容器中拿取若干个巧克力，使得拿取完之后再计算的Nimber异或值为0。

假设对于某个容器，当前巧克力数为i， 拿取完之后巧克力数为j，则有 g ^ i ^ j = 0。可以这样理解, (g ^ i)是除此容器外其他容器的Nimber异或结果，再异或上新的巧克力数，应该等于0。

则 j = g ^ i。 可以看到，j的值是确定的，也就是说，如果选定了某个容器去拿，拿完之后剩余巧克力数是确定的。

除此之外，还有一条限制，自然是， j < i，因为只能拿走，不能往里放。

这样对每个容器进行检查判断，能够达到上面条件的容器，就代表可用策略+1。

但我做的时候，感觉自己又多做了一步。

我的做法是，对于g的最高位，检查i对应位置是否是1.

因为g的最高位是1，与i异或之后，对应位发生改变，如果是0 -> 1，那么就需要从前面借位来减，那么前面的位也会发生变化，这样就与此位是变化的最高位矛盾。

而 1 -> 0时，后面的位无论怎么变，都是够减的，因为这一位已经比后面的都大了。

具体代码见[solve.php](./solve.php)