# The Value of Friendship
原题见[这里](https://www.hackerrank.com/challenges/value-of-friendship/problem)

你在研究n个学生之间的友谊关系，他们编号从1到n。

一开始，所有人都不是朋友，而随着时间，他们中一部分会认识并且建立友谊关系。同时友谊关系有如下性质：
* 双向性。a是b的朋友，则b也是a的朋友。
* 传递性。若a是b的朋友，b是c的朋友，则a也是c的朋友。

你的目的是找到一个定义为total的值的最大值。total值的定义如下：
* 每当有两个直接的朋友关系达成，total就增加“每个学生拥有的朋友之和”。

注意，上面说的是有“直接”的达成，也就是说通过传递性形成的朋友不算。例如，a与b是直接朋友，b与c是直接朋友，此时a与c建立友谊关系，则total增加(a的朋友数+b的朋友数+c的朋友数+...+z的朋友数)。

# 分析
这当然是，看做一个图来处理。

由于双向性和传递性的存在，最终图会形成若干个互不相交的子图，也就是两个子图之间没有边相连。

换个方式想，就是朋友是会扎堆的，某一群人形成一个朋友圈，另一群人形成另一个朋友圈，而这两个朋友圈之间没有来往。

所谓的“直接”关系达成，其实就是给定数据的每一行（我在这里假定没有重复出现）。

每一行，要么会形成新的朋友关系，要么不会（之前已经通过传递性是朋友了），而如果想让total值最大，当然是让每次增加的朋友关系数都越大越好。

第一步，total自然只能增加2，因为只能让两个人成为好友，他们彼此有1个朋友。

第二步，最好的做法是有一个人加入第一步形成的朋友圈，这样total能增加6，也就是一共3个人，每人2个朋友。

第三步，同样的，再有一个人加入上面的朋友图，total增加 4 * 3 = 12

...

以此类推。

所以可以看到，好的做法是对于最终形成的互不相交的子图，先把一个子图连通完成，再去处理下一个子图，并且保证连通子图的时候每一步都有新的朋友关系加入。

那么，对于两个子图而言，要先处理哪个，后处理哪个呢？答案是，先处理最终人数多的，这样每一步total值的增加量才会更大，在处理后者的同时，前者的关系总数也是每一步都会加到total值中去的。

假设两个子图，一个节点数为s，一个节点数为t。若先处理s，则最终total增加值为以下三段之和
* 处理s过程中增加量 1*2 + 2*3 + 3*4 + ... + (s-1)*s
* 处理t过程中s贡献的增加量 t*s*(s-1)
* 处理t过程中t贡献的增加量 1*2 + 2*3 + 3*4 + ... + (t-1)*t

若先处理t，而第一段和第三段之和是一样的，就是上面的第一段和第三段交换，而第二段会变成 s*t*(t-1)，这是比上面的要小的。

那么，如果之前已经是朋友关系了，这一步“直接”达成，不会形成新的关系呢，那当然是放到后面，等全部子图都连通完毕了再来处理。因为这一步不会形成新的关系，而处理其他子图会形成新的关系，增加量会更大。

这样，最终的算法就得出来了。
1. 找出所有的互不相交的子图，按数量从大到小排序。
2. 假设“直接”达成的关系数为m，最终互不相交子图的数量从大到小为t1,t2,t3...tn。
    * 对于t1,贡献增加量为 1*2 + 2*3 + 3*4 + ... + (t1-1)*t1 + (m-t1) * (t1-1) * t1
    * 对于t2,贡献量为 1*2 + 2*3 + 3*4 + ... + (t2-1)*t2 + (m-t1-t2) * (t2-1) * t2
    * 对于t3, 贡献量为 1*2 + 2*3 + 3*4 + ... + (t3-1)*t3 + (m-t1-t2-t3) * (t3-1) * t3
    * ...
    * 对于tn，贡献量为 1*2 + 2*3 + 3*4 + ... + (tn-1)*tn + (m-t1-t2-t3 ... -tn) * (tn-1) * tn

可以预先计算并缓存对于数字i，(i-1)*i 以及 1*2 + 2*3 + 3*4 + ... + (i-1)*i的值，这样就不用重复计算它们，直接取值即可。

具体代码见[solve.php](./solve.php)