# Yet Another KMP Problem
原题见[这里](https://www.hackerrank.com/challenges/kmp-problem/problem)

给定字符串S，长度为N，下标从1到N。

kmp[i]存储的是子串S[1]-S[i]的满足特定条件的最长前缀长度（必须小于i），需要满足的条件就是这个前缀字符串同时也是子串S[1]-S[i]的后缀。

例如，假设S = cabcabcd, i = 7，则kmp[7]存储的是子串s[1]-s[7]，即cabcabc的最长前缀长度，同时这个前缀字符串也是cabcabc的后缀。

则kmp[7] = 4，因为前缀cabc同时也是cabcabc的后缀，而且是所有满足条件里最长的。

又例如， i = 2, 则kmp[2] = 0，因为，对于ca而言，没有任何前缀满足条件。

现在，给定一个序列x[1],x[2],x[3],...,x[26]，要求构造一个字符串S，同时满足以下条件：
1. 字母'a'在S中出现x[1]次，'b'出现x[2]次，'c'出现x[3]次，依此类推，'z'出现x[26]次。
2. 假设S长度为N，下标从1到N，对S计算上述kmp表，并对kmp表每项求和。现要求构建的S必须保证计算出的kmp表求和结果最小。

如果能够构造出多个字符串，则输出字母序最小的那个。

例如，现在要求a出现3次，b出现1次，c出现1次，则输出的字符串应是baaac。原因如下：
* 若以a开头，则后面以a结尾的子串对应的kmp值至少等于1。而若以b或c开头，全部kmp值都等于0.
* baaac是kmp值之和为0的字符串中字母序最小的。

# 分析
这道题，需要分类总结规律，总结出来，算法也就出来了。

## 结果最小的和
首先，要找的规律是，结果最小的和是多少。

### 只出现一个字母
这种情况，没有啥可说的，根本无法操作一郎，就只有一种字符串排法。这时也不用考虑结果最小的和是多少了

### 出现多个字母
在这里，这样考虑，对于最终字符串中的首个字母而言，有没有可能存在构造方式，使得其他位置i对应的kmp[i]，如果S[i]等于S[1]的话，kmp[i] = 1，否则kmp[i] = 0呢？

这个也是以某个字母开头能够构成的字符串的kmp表和的下界了，因为如果S[i] = S[1]的话，kmp[i]至少为1。

答案是，有的。不妨设首字母为a，出现的其他字母分别为l[1],l[2],...l[t]，共t种。

则采用如下方式进行构造，首字母为a，接着将所有的字母l[1]全部跟在a后面，之后的随便排，这样得到的字符串就能满足条件。

对于所有字母l[1]所在的位置，对应的kmp值都为0，因为按照kmp值的定义，最长后缀必须以a开头，而这里a是首字母，因此不存在以a开头的后缀了。

对于字母l[1]之后的位置，如果字母为a，则对应kmp值为1，如果不为a，对应kmp值为0，因为整个字符串中，除开头之外，再也没有1个a后面跟着1个l[1]了。

这样就证明完成了。

然后可以发现一点，要得到最小的kmp表各，首字母必须是出现次数最少的那个，如果存在多个次数最少的，则取字母最小的那个。

那么，确定了首字母之后，再继续分析如何得到字母序最小的排列。

## 最小字母序排列
首字母确定后，第2个字母放什么好呢？又要分两种情况讨论。

### 首字母不是所有出现字母中字符序最小的
这样的情况，首字母后面就跟着字符序最小的字符，然后后面再跟着次小的字符，依次下去。这样得到的字母序必然是最小的，而且由于摆放方式跟上面证明时摆放的结构相同，因此符合条件。

### 首字母是所有出现字母中字符序最小的
这样的情况，自然是希望尽可能的将此字母往前放。

如果首字母仅出现1次，则可以看做退化为“首字母不是所有出现字母中字符序最小的”的情况，依次摆放即可。

如果首字母出现2次及以上，接下来怎么放呢，答案是放一个首字母，再放一个字符序次小字母，再放一个首字母，再放一个字符序次小字母，直到首字母次数用尽，后面的就按字符序依次摆下去。

下面来证明这种方法得到的是最小的满足条件的字母序排列。

首先，第2个位置放首字母，整个字符串S肯定比第2个位置放其他字母的方法要小。

然后，要做到kmp[i]值不是0就是1，则不能再出现两个连续的首字母。

现在，既想要将首字母向前排，又不能出现两个连续的，怎么做呢，当然是放一个其他字母，再放一个首字母，交替进行了，而要让这部分也达到最小，则这个“其他字母”就应该取次小字母。

那么，整个题目的算法就出来了：
1. 遍历输入，得到出现次数最少的字母，如果有多个次数最小的，则取字母序最小的，假设为mintime。得到出现的最小的字母，假设为minalpha，出现次小的字母（如果有），假设为salpha同时统计出现多少种字母，假设为cat。
2. 如果cat = 1，返回唯一的字母排序方式。否则转3.
3. 分两种情况。
    * 如果mintime != minalpha，最终字符串S如下：首字母mintime，剩余的将所有字母按序从小到大依次排列。
    * 如果mintime = minalpha，最终字符串S如下： 首字母mintime，然后mintime与salpha交替摆放直到mintime次数用尽，剩余的将所有字母按序从小到大依次排列。

具体代码见[solve.php](./solve.php)