# Bonetrousle
原题见[这里](https://www.hackerrank.com/challenges/bonetrousle/problem)

原文说了些冷笑话，我就不翻译了。

给定k个盒子，编号从1到k，每个盒子里的火柴（原文是stick，我胡乱翻译的）数与编号数相同。也就是，1号盒子里有一根火柴，2号有2根，3号有3根，依此类推。

现在，要你从中选择b个盒子，使得它们里的火柴总数等于n。若有解，输出其中任意一种解法包含的盒子编号，若无解，输出-1.

# 分析

选择b个盒子，火柴总数最小是多少？当然是，选编号最小的b个盒子，总数为(1 + b) * b/2。

那总数最大是多少？对称的，选编号最大的b个盒子，总数为(k + k - b + 1) * b / 2。

所以，如果n小于最小总数，或是大于最大总数，那肯定是没有解了。

然后，对于位于这两者之间的每个数量i，是不是一定会能有一种选法，使得火柴总数等于i呢。答案是，是的。下面来证明这一点。

我们假定选择b个盒子是排好序的，编号小的排在前面。

假定选择方案数组为s。首先，让b个盒子是最小的选法，即从小到大编号是 1 到 b， s[i] = i。

接下来，做这样的操作，每一次操作，让s[b] 自增1， 也就是编号最大的盒子从b, b + 1, b + 2,  一直到k。它在数组中始终是最大的。

可以看到，每次操作，火柴总数都+1。

继续对s[b-1]做类似的操作，它的编号从b-1一直到k-1，保持它始终是数组中第2大的。同样的，每一次火柴总数也是+1.

再继续对b-2, b -3, ... 1做同样的操作，最终得到的数组s就变成了最大的选择方案了。

而由于每一次操作，火柴数的变化都是1，所以最小与最大方案中的每个数字都会对应一种选择方案。

与此同时，解法也就出来了，就按照上面的方式不断操作，直到火柴总数等于要求的数量为止。

当然，实际操作的时候，并不是1次变化1步，而是有更快的方式。

注意一点，编号最大的盒子，能从b 变化到 k。第2大的盒子，能从b - 1变化到 k - 1，第 i 大的盒子，从 b - (i - 1)变化到 k - (i - 1)。

发现什么没有？是的，每个位置能够贡献的最大变化数都是 k - b。这样可以直接计算出需要多少个位置取能够达到的最大编号。

那么，对于n可以达到的情况，实际算法可以这样：
1. 计算n与最小火柴总数的差值d。
2. 计算 mod = d % (k - b), t = (d - mod) / (k - b)，t代表末尾有多少个位置需要达到其最大编号，而mod表示第 k - t个位置还需要操作多少步。
3. 按照上面的做法输出结果，前 k - (t + 1)个位置取与其索引相同的编号，第 k - t个位置取 k - t + mod，后面的位置取能够达到的最大编号。

说起来的话，要不是输出数组需要循环的话，实际这是O(1)的题目啊

具体代码见[solve.php](./solve.php)