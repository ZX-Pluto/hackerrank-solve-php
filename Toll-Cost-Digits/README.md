# Toll Cost Digits
原题见[这里](https://www.hackerrank.com/challenges/toll-cost-digits/problem)

这个可以看作一个有向图，每个交叉点(junction)就是一个点，一条路（toll road）表示两条有向边。

对于一条路i，对应的信息是 x(i), y(i)和r(i)， 表示存在一条 x(i) -> y(i)的边，权值为r(i)，同时存在一条 y(i) -> x(i)的边，权值为 1000 - r(i)。

题目要求的是， 计算出所有起点和终点不同的路径中， 权值之和尾数为0, 1, 2 ... 9的数量d(0),d(1)...d(9)。 对于同一个尾数，每对起点和终点只计算一次。 

即假设起点为x,终点为y，且x != y， 如果存在一条或多条以x开始，以y结束的路径，权值之和尾数为z，则d(z)数量加1。

# 分析

## 我自己思考的一种稍微复杂的解法

我的想法是，对于某个还未处理过的节点，找到它所在的强连通分量，然后针对此强连通分量计算d，并将些强连通分量中的节点都设置为已处理过。接着再继续遍历未处理过的节点，直到全部节点都处理过了。

我是应该解释下强连通分量是啥，不过之前的文章里似乎做过这事， 见[这里](https://github.com/tianhe1986/hackerrank-solve-php/tree/master/Recording-Episodes#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F)

在一个强连通分量中，要计算每两个节点之间可能的路径尾数，全部都两两遍历一遍储存的的话，空间复杂度太高。于是，我想的办法是：
1. 选择某个节点s为起点，计算以其他节点为终点，可能的路径尾数。
2. 计算x -> y可能的路径尾数，拆成两部分 x -> s, s -> y， 用这两部分计算，再进行组合。

对于第一点的计算， 对于某个节点t,如果 s->t的尾数出来了，则t->s的尾数也就出来了。对于s->t的某条路径，若尾数为p，则与此路径对称的t->s的路径尾数为(10 - p) % 10。
因为题目给的每条路的信息，代表了对称的两条边，若在s->t中取了某一条，则在t->s中取对称的另一条即可。

而第二点的计算，就是基于第一点的结果。

但是，但是，但是，就在这里我想岔了两点。：
1 没有想到如果用第一点的尾数统计结果，即以s为起点，所有路径尾数的统计数量，去快速计算出第二点，我想的还是节点两两去计算，导致时间复杂度太高。
2 在计算第一点的时候，我没有一次性直接遍历出所有s -> 其他节点的路径尾数，而是在中间又考虑了环的问题。

### 环的问题
我的想法是，先遍历出s为起点，其他节点为终点，且没有环的路径尾数，再用环的路径尾数去更新这些尾数。这样做基于以下一点：
* 对于任意节点s1和s2， 以s1为起点和终点的全部环，和以s2为起点和终点的全部环，它们构成的路径尾数是相同的。

因为对于任意一条以s1为起点和终点的环 s1 -> ... -> s1， 可以构建s1->s2和s2->s1的对称路径，则 s2->s1->...->s1->s2的路径尾数与前一个环是相同的，因为两条对称路径的尾数之和为0，则对于所有节点都能构成相同的路径尾数。

接着，又发现环的路径尾数可以分为以下几种情况：
* 仅包含尾数0.
* 仅包含尾数0和5.
* 仅包含偶数尾数。
* 包含全部尾数。

这里我就不全部说明了，以仅包含偶数尾数为例，其他的可以自己思考下。

首先，如果包含一个不为0的偶数尾数，则包含其他所有偶数尾数。
以2为例，如果某个环尾数为2，则这个环绕2次，能得到尾数4，绕3次得到6，4次得到8.。类似的，其他偶数也是一样。

然后，不包含奇数尾数。因为如果包含了奇数尾数，假设是j，则由于同时包含所有偶数尾数， 则也包含 （11 - j) % 10的尾数，这两个环组合，就能得到为1的尾数，进而会包含全部尾数，落入另一种情况。

我最终根据环的尾数情况与s为起点，其他节点为终点的尾数情况，用排列组合公式计算得出各个尾数统计数量之和，总之是对了但是挺复杂的。

具体代码见[solve-complex.php](./solve-complex.php)

## 流程更简单的解法

其实就是我没有想岔就好了。。。

对于强连通分量，计算出以s为起点，以其他节点为终点，每个尾数的统计数量。 对于s，贡献的尾数数量就是这些。

接着，再把以s为起点，以s为终点的每个尾数数量也加到统计里去。 令此时的统计结果分别为c(0),c(1)...c(9)，代表的是以s为起点的所有路径尾数统计数量

对于其他任一节点t， 肯定存在一条或多条以t为起点，s为终点的路径，任选一条，假设此路径 t -> s尾数为 e, 以t为起点的所有路径尾数统计数量分别为ct(0),ct(1)...ct(9)，则有：
* ct(k) = c( (k - e + 10) % 10)
即t先走到s，再从s走到其他节点。

这里可能有一点难理解，比如说，这样走，那肯定会经过s，但是有些路径可以不经过s的，会不会没有统计到。 没错，这样确实经过了s，但是只要能够抵销掉s对尾数带来的影响即可。

假设t到任一节点t'的路径为t ->  ... -> t'， 则可以构建新路径 t ->s -> t -> ... -> t'， 其中t->s和s->t走对称的路径，则这一段对称的路径尾数之和为0， 不影响原有尾数，即两者等价。
而现在这条路径就包含在t先走到s，再走到t'的路径中，是会被统计到的，而根据题意，同一尾数无需重复统计，因此没有影响。

但是还有一个问题，现在的ct(k)是包含了t到自己的路径的，而根据题意，是不需要的，那么剔除掉就好，公式更新为：
* ct(k) = c( (k - e + 10) % 10) - ( c( (k - e + 10) % 10) 中包含t ? 1 : 0)

这样结果就对了。

注意，由于是PHP，我不得不做了些优化，使用SqlFixedArray来处理队列，队列中的每项也只保存一个数字，节点的id * 10 + 尾数，否则内存会超。。。。

具体代码见[solve.php](./solve.php)