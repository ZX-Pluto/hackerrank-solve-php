# Minimum Penalty Path
原题见[这里](https://www.hackerrank.com/challenges/beautiful-path/problem)

一张图，N个节点，M条边，每条边有一个花费C。一条路径的总花费，是这条路上的所有边的花费进行或(or)操作，就是位运算中的或计算。

例如，一条路径包括边m[1],m[2],m[3]...m[k]，对应的花费是c[1],c[2],c[3]...c[k]，则总花费是 c[1] | c[2] | c[3] | ... | c[k]

现在给定两个节点A和B，要求一条花费最小的路径，输出最小花费，如果两个节点之间不可达，输出-1.

注意：两个节点之间可能有多条边。

# 分析
这道题，我一开始又想岔了，想的是用迪杰斯特拉算法找起点到每个节点的距离最小值。然而对于或操作而言，是行不通的。

举个简单的例子，就三个节点，1，2，3，要求从1到3的最小路径，图中有如下三条边:
* 1 - 2, 花费为3
* 1 - 2, 花费为4
* 2 - 3，花费为4

如果用迪杰斯特拉算法，到节点2的花费最小值是3，但是接着遍历的话，会求出1到3的最小花费是7，而实际上，最小花费应该是4，在此路径中，1->2使用的不是花费最小的边。

那么怎么办呢？ 一个字，莽！两个字，穷举！

根据题意，每条边的花费最大为1023，那么，从起点到每个点的花费也最多是1023。穷举全部的可能，记录到每个点的每个花费值是否存在。最后，对于终点，检查出现的最小花费即可。

具体代码见[solve.php](./solve.php)