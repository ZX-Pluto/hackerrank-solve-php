# Cloudy Day
原题见[这里](https://www.hackerrank.com/challenges/cloudy-day/problem)

哥伦比亚的基布多以降雨多而闻名。

假设这个城市由许多镇组成，座落在一条直线上。每个镇的坐标和人口已知。

同时这个城市也被很多云覆盖，云的中心点和半径已知，如果一个镇被一朵或以上的云覆盖，则认为这个镇是阴天，否则为晴天。

科技进步了，有办法移除其中的一朵云，但是也没有进步到足够发达的地步，所以只能移除一朵。当然，移除的原则是，能够将最多的人从阴天中解放出来。

现在问，在移除一朵云之后，最多能有多少人沐浴在阳光之下呢。

# 分析
这道题我想了两种解法，一种是线段树，另一种是扫描线。

## 线段树解法
之前讲过线段树了，见[这里](../Quadrant-Queries)

线段树对应的原始数据是什么呢，是每个镇上空的云朵数量，处理方式就是对每朵云，找出它覆盖的镇范围，然后进行更新。

因此算法步骤就有了：
1. 将镇按坐标排序并重新编号。
2. 创建线段树，记录的是每个镇上空的云朵数量，以及最后一朵云（如果有）的编号。
3. 遍历每朵云，根据它覆盖的镇坐标范围更新线段树。在这里，用二分查找来找覆盖的镇起点编号和终点编号。
4. 遍历每个镇。
    * 如果没有被云覆盖，直接将人口加到晴天人口中去。
    * 如果被一朵云覆盖，将人口加到移除该云能解放的人口数中。
    * 如果被两朵或以上云，什么也不做。

实际处理过程中还可以稍微优化一下，更新线段树时，如果当前范围已经有了两朵云，就无需再继续更新了，因为已经影响不了结果了。

具体代码见[solve_segtree.php](./solve_segtree.php)

## 扫描线解法
在百度上搜了一下，搜出来的第一页大多是求矩形面积的什么，没有一个讲“扫描线算法”本身到底是怎样的。

于是换bing搜英文（科学上网被墙了），出来的才是我想要的。扫描线算法主要针对离散点进行处理的基本思想是：
1. 沿着一条线进行扫描，通常把这条线抽象为二维平面上的x轴上从原点开始的线段，从左向右扫描。
2. 这条线上的某些点，都会存有一些事件，它们是有优先级顺序的。
3. 扫描到某个点时，按照优先级依次处理这些事件（要求解的问题通常也抽象在事件中），最终扫描结束，得出结果。

以这道题为例，要扫描的线段就是题中的坐标，从0到最大坐标为止。

而对于每个整数坐标（根据题意都是整数），可以抽象出对应的三种事件
1. 进入了某朵云的覆盖范围。
2. 离开了某朵云的覆盖范围。
3. 到达了某个小镇。

而扫描中我们需要维护一个数据结构，就是当前被哪些云覆盖了。对于三种事件，分别做的处理如下：
1. 进入了某朵云的覆盖范围，则将此云加入到当前覆盖的云中。
2. 离开了某朵云的覆盖范围，则将此云从当前覆盖的云中移除。
3. 到达了某个小镇，则检查当前覆盖的云数量。然后做的处理跟上一步线段树算法中的第四步对小镇的处理相同。

实际处理的时候，还可以更加优化，没有必要真的遍历每个点，而是针对小镇扫描即可，将前两种事件也附加在小镇上。

具体代码见[solve.php](./solve.php)