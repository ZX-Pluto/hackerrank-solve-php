# Wet Shark and Two Subsequences
原题见[这里](https://www.hackerrank.com/challenges/wet-shark-and-two-subsequences/problem)

给定一个数组X，要求找出所有满足条件的子序列组合(A, B)的数量，其中A和B满足以下条件：
* A和B必须长度相同。
* 令A中每项之和为sum(A)，B中每项之和为sum(B)。则sum(A)+sum(B) = r。r是给定的一个数。
* sum(A) - sum(B) = s。s是给定的一个数。

# 分析
这个题目看着就像动态规划的题。

首先，把题意换一下，就要求sum(A) = (r+s)/2， sum(B) = (r-s)/2。

然后动态规划怎么操作呢？自然是记录下能够组成的和及长度的数量，最后将能够组成sum(A)和sum(B)的各个对应长度数量相乘，再累加。

举个例子，假设sum(A) = 70， sum(B) = 20。现在记录了能够组成和为70的各子序列长度及数量为
```
a = [1 => 5, 3 => 6, 5 => 7, 6 => 8]
```

而能够组成20的为
```
b = [2 => 5, 3 => 7, 5 => 8, 7 => 9]
```

则总数量为相应长度数量相乘再累加， 即 a[3] * b[3] + a[5] * b[5]（中间的a[1],b[2]等，因为另一个数组中没有对应项，则忽略）

实际动态规划递推的时候，我是按数组从前往后遍历的，每一轮的结果是“最后一项的位置《=当前位置”时的和及对应长度。

即，假设原始数组为x，dynamic就是用来遍历的二维数组，dynamic[i][j]表示和为i，且长度为j的子数组数量。

一开始，设置dynamic[0][0] = 1，即和为0，一项都没有的数量为1.其他值都为0

然后，第一轮，新建一个新数组newDynamic，对于x[0]，有如下递推公式：
* newDynamic[i][j] += dynamic[i - x[0]][j-1]，即和为i，长度为j的数量，除了之前的以外，还要再加上最后一项以x[0]结尾的情况。

再设置dynamic = newDynamic，清空newDynamic，继续第二轮对于x[1]递推即可:
* newDynamic[i][j] += dynamic[i - x[1]][j-1]。

依此类推，即第k轮会加上以第k项结尾的情况，累加到最后就是全部的情况了。

实际处理时，我没有用两个数组，直接在dynamic原数组上进行操作，只要从大到小依次操作就行。

同时，还有一点小小的优化，最大只需要计算到(r+s)/2即可，因为超过它的和不会被用上了。

具体代码见[solve.php](./solve.php)