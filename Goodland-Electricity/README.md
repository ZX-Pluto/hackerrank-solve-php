# Goodland Electricity
原题见[这里](https://www.hackerrank.com/challenges/pylons/problem)

Goodland是个国家，所有的城市排在一条线上，每个城市之间的距离都是1.

现在，打算在一些城市建电力设施，让电力能够覆盖整个国家全部的城市。

给定电力设施的范围k，它能够覆盖的范围是距所在城市距离小于k的全部城市。

同时，不是所有城市都可以建电力设施的，每个城市有一个标识，代表是否可以建造。

现在给定n个城市，每个城市的标识和电力设施范围k，问至少需要建多少个设施才能覆盖全国。如果不能，则返回-1。

例如，对于k = 2， n = 6， 标识为[0, 0, 1, 1, 0, 1]，结果就是0，因为设施只能覆盖距离小于2的城市， 因此编号为0的城市，无论如何，都没有办法被覆盖到。

又比如k = 2， n = 6， 标识为[0, 1, 1, 0, 1, 1]，结果就是2，分别在城市1和城市4建立设施，城市1所在的设施能覆盖0，1，2, 城市5所有的设施能覆盖3, 4, 5。

# 分析
由于最终必须每个城市都被覆盖，那么考虑从左向右覆盖。

在每次成功新建设施之后，都有唯一的一个城市i，在它左边的城市都已经被覆盖了，它自己以及它右边的城市都未被覆盖。

接下来，就要选一个城市建造，使得城市i能够被覆盖，同时能够尽量多的覆盖其他仍未被覆盖的城市。

那么， i + k - 1这个城市当然是最理想的，既能覆盖i，又将覆盖的城市数达到了最大。

如果这个城市没法建城市呢，就继续向左查找， i + k -2, i + k -3, ... i + 1, i, i - 1, ...i - k + 1，选择这些城市中能够建造且编号最大的城市。

因为必须要覆盖i，所以只可能在这些城市中建造，同时，编号越大，能够向右方覆盖的城市数就越多，所以这样的做法选出的城市是满足条件的最优者。

实际处理的时候，可以稍微优化下，没必要真的每次都循环遍历，而是记录下某个城市左方最近的可以建造的城市leftNear，然后当i及它右边的城市都未被覆盖时，检查leftNear[i + k]是否大于i - k即可

具体代码见[solve.php](./solve.php)