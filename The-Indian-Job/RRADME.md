# The Indian Job
原题见[这里](https://www.hackerrank.com/challenges/the-indian-job/problem)

有中文，就不翻译了。

# 分析
从题意看来，是需要将劫匪划分成两个集合，每位劫匪必须在且仅在其中一个集合，同时每个集合中的劫匪停留时间之和 <= G。

首先处理两种极端的情况：
1. 所有劫匪停留时间之和 <= G，那么很显然，就算任何时刻只有一个人，也是满足条件的。
2. 所有劫匪停留时间之和 > 2*G，也很显然，不可能满足条件，时间是不够用的。

那么对于剩下的情况呢？只要 G >= 其中任一集合的停留时间之和 >= 全部停留时间的一半（向上取整） 即可。

那么就可以看做，总容量为G，每个劫匪的容量和价值相等，等于需要停留的时间，在不超过总容量限制的情况下，选择若干劫匪，使得价值最大，如果最大价值 >= 全部停留时间的一半，则满足。

上面这个是不是听起来有点耳熟，仿佛在哪见过类似的？是的，就是背包问题了。

解背包问题，就是典型的动态规划了。

令dynamic(i, j)表示从前i个物品里取，且当前剩余容量为j时，能够得到的最大价值，假设容量数组等于价值数组，为cost有：
* 若 i = 0, 当cost[0] <= j时，返回cost[0]，否则返回0。即只有一个物品可以取时，能取则取。
* 否则， dynamic(i, j)为以下两者中的更大值：
    * dynamic(i - 1, j)，即第i个物品不取时能够得到的最大价值。
    * dynamic(i - 1, j - cost[i]) + cost[i]，即取第i个物品时，能够得到的最大价值。注意，这里有个前提条件，就是必须满足 j >= cost[i]，否则第i个物品是绝对没有办法取的。

就这样求出dynamic(n - 1, g)，与全部停留时间的一半对比即可。

具体代码见[solve.php](./solve.php)