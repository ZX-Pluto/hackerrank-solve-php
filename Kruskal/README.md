# Kruskal (MST): Really Special Subtre
原题见[这里](https://www.hackerrank.com/challenges/kruskalmstrsub/problem)

给定一个无向连通图，要求找它的最小生成树。最小生成树是由原图的全部节点和一部分边构成的，满足以下条件：
* 每个节点到另一个节点只有唯一的一条路径
* 此图在所有满足另外两个条件的子图中，全部边的权值加起来是最小的。
* 图中没有环（这一点我觉得其实跟第一条重复了，有环的话，自然就有两条以上的不同路径了）

构建最小生成树的具体操作如下：
1. 初始化新图，所有边都未保留，边总权值为0。
2. 对所有边，按权值从小到大的顺序遍历。遍历处理如下：
    * 如果将此边加入，会构成一个环，则不处理，否则将此边加入到新图中，边总权值加上此边的权值。

# 分析

上面的题目说明中，已经把算法思想说得比较明白了。

其中有一个问题，如何记录和判断当前遍历边对应的两个点是否在不同连通子图中（即连接它们不会构成环）。

这里使用的是一个parent数组，如果某个节点i对就的parent[i]为空，则它是当前连通子图的根。
否则，继续遍历查找parent[parent[i]]，直到找到根为止。

如果两个点最终对应的根相同，则在同一个子图，否则就不在。

两个子图合并成一个，则设置其中一个子图对应的根j作为另一个子图根k的parent，即parent[k] = j。
这样，之前所有k所在子图的节点，对应的根也就都变成j了。

具体代码见[solve.php](./solve.php)