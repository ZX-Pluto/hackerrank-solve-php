# Grid Walking
原题见[这里](https://www.hackerrank.com/challenges/grid-walking/problem)

给定一个n维的网格和初始位置(x[1], x[2], ... , x[n])，以及每一维的最大值(D[1], D[2], ... , D[n])。

每一步，你可以沿着任意一维走1步， 即选择一个维 1 <= i <= n， 然后走到 x[i] - 1或x[i] + 1的位置，但是有一点限制，不能走到网格外面去。
也就是必须始终保证 1 <= x[i] <= D[i]。

很显然，如果不考虑出界问题的话，每一步都有2n种走法。

现在给定m，即一共走m步，问可能形成的路径有多少条？

# 分析
如果只有一维的话，可能形成的路径有多少条，要怎么求呢？当然是，用动态规划（其实也可以算是穷举），从起点开始，每一步都尝试往两个方向走，再遍历下个位置。

那如果是两维呢？首先我们需要观察到一件事，那就是每个维度的走法是完全独立的，也就是，某个维度上的走法，不会影响到其他维度的走法选择。

那么对于两个维度，假设在两个维度上的步数分别是a和b， a + b = m， 则对于此情况，可能的路径条数为 C(m, a) * 维度1走a步的路径数 * 维度2走b步的路径数。

以上公式的意思是， 从m步中选择a步，作为维度1的路径，然后对两个维度分别计算固定步数的路径数。

那么总步数呢，就是a依次取0, 1, 2, ... m，再将计算出的路径数求和即可。

再扩展一下，对于三个维度，步数分别是a,b,c，那么，先从m步中选择a步，作为维度1的路径，再从m - a步中选择b步，作为维度2的路径，再乘上三个维度各自走固定步数的路径数即可。

推广到n维，假设步数分别是s[1],s[2],s[3]...s[n]，则对于每一维i，需要计算：
* C(剩余步数, s[i]) * 第i维走s[i]步的路径数

将所有的这些相乘，就是步数固定为s[1],s[2],s[3]...s[n]时路径数了。

总数径的话，就是依次遍历每一维可能的步数求出路径数，再累加求和。

具体代码见[solve.php](./solve.php)