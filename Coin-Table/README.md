# Coin on the Table
原题见[这里](https://www.hackerrank.com/challenges/coin-on-the-table/problem)

n行m列，共n * m个方格，左上角坐标为(1, 1)， 右下角坐标为(n, m)。

在时刻0，有一枚硬币放在左上角的方格中，每个方格包含如下字母之一：
* '*': 有且仅有一个方格包含字母'*'
* 'U': 如果在时刻t，硬币在方格(i, j)且(i, j)包含字母'U'，则在时刻t+1， i > 1时，硬币将移动到方格(i - 1, j)，i = 1时硬币将移除掉不再回来。其实就可以看作是硬币会向上移动一格。
* 'L': 类似的，向左移动一格，从(i, j)移动到(i, j - 1)
* 'D': 下移一格，从(i, j)移动到(i + 1, j)
* 'R': 右移一格，从(i, j)移动到(i, j + 1)

硬币到达'*'方格，就不再移动了。当游戏开始后，会进行计时，硬币会在方格之间移动。

在游戏开始之前，你可以做一些操作来更改方格，以便于保证能在时刻k之前使硬币到达'*'。每一步操作，你可以选择一个不是'*'的方格，并将字母转换成'U','L','D'或'R'。

你需要计算出，要让硬币在时刻k之前到达，需要做的最少操作步数。如果做不到，返回-1.

# 分析
这个就是动态规划直接莽了，让dynamic(i, j , remainStep)表示目前硬币位于i， j，并且需要在remainStep步内到达终点的情况下，所需要做的最少操作步数。则有：
* 若(i, j)对应点为'*'，返回0。
* 否则，往上下左右四个方向进行遍历，其中操作步数最小者。即如下四种情况中的最小者：
    * 若 i > 0， 往上遍历， temp = dynamic(i - 1, j, remainStep - 1) + (i, j)对应格为'U' ? 0 : 1;
    * 若 j > 0， 往左遍历， temp = dynamic(i, j - 1, remainStep - 1) + (i, j)对应格为'L' ? 0 : 1;
    * 若 i < n - 1， 往下遍历， temp = dynamic(i + 1, j, remainStep - 1) + (i, j)对应格为'D' ? 0 : 1;
    * 若 j < m - 1， 往右遍历， temp = dynamic(i, j + 1, remainStep - 1) + (i, j)对应格为'R' ? 0 : 1;

具体代码见[solve.php](./solve.php)