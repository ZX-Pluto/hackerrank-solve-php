# New Year Chaos
原题见[这里](https://www.hackerrank.com/challenges/new-year-chaos/problem)

n个人排成一队，在等着玩过山车，每个人都有一个标签，表示在队列中的原始位置。一开始，第1个人标签是1，第2个人是2，依此类推，第n个人是n。

有些人想提前一点玩到，那怎么办呢？他可以贿赂排在他前面直接相邻的那个人，并与他交换位置。但是有个限制，每个人最多只能实施两次贿赂行为。

给定最终经过贿赂交换的队列，问最少要通过多少次交换才能从初始队列变成这样。如果无法达到，输出Too chaotic

# 分析
首先，交换有两种，主动交换和被动交换。

主动交换，就是上面说的，贿赂其他人，让自己的位置更靠前。被动交换，就是被贿赂的那个人，会往后走，位置变得靠后。

2次的限制，是对于主动交换而言的，翻译一下就是，如果某个人的原始位置为i，最终所在位置为i'，则必须有 i - i' <= 2 

然后，在满足限制的情况下，要求的交换数是多少呢？其实就是数组中的逆序对数，也就是，如果对于两个人a和b，如果一开始在队列中a排在b之前，而之后变成b排在a之前，那么它们就构成了一个逆序对。

同时，由于只是相邻的人才能进行交换，那么，要变成b排在a之前，则他们必然进行了交换。

求逆序对，最直观的方法就是两重循环遍历，比较任意两个元素的大小关系。

另一种方法，就是使用归并排序，我参考的是[这篇文章](https://www.geeksforgeeks.org/counting-inversions/)

归并排序处理的算法见[solve-merge.php](./solve-merge.php)

后来看了题目编辑的答案，恍然大悟，原来是有取巧的办法的。

取巧的办法就是，从后往前，对每个人的原始位置对比最终位置进行遍历（因为每个人最多前移不超过两步），并将其还原到原始位置，这样陆续处理，就可以得到逆序对数了。

具体代码见[solve.php](./solve.php)