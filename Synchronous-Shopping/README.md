# Synchronous Shopping
原题见[这里](https://www.hackerrank.com/challenges/synchronous-shopping/problem)

Bitville是一个城市，里面有n个商店，标号从1到n。商店之间通过路相连，通过每条路都需要花费一定的时间。

一共有k种鱼，每个商店都卖其中的多种，也可能不卖。

有两只猫，大猫和小猫，它们都从商店1出发，分别在各个商店逛，最后在商店n碰头，在每个商店逛时，可以选择买此商店中的鱼。

它们碰头的时候需要满足一个条件：两只猫买的鱼种类合并起来，要凑齐全部的k种鱼，问它们完成碰头所需的最短时间。显然这个时间会是后到的那只猫在路上花费的时间。

# 分析
我一开始又想岔了，我想的是找一个包含节点商店1和商店n的环，环上能够买到全部的鱼，而且环的周长最小，然后，最小循环流？感觉好复杂。

后来想了想，还是应该从题意入手，一步步发掘出解法。

首先，碰头，自然意味着两条1->n的路径，那么，凑齐就意味着这两条路径结束时，分别买到的鱼，合在一起，覆盖了全部的鱼。

那么，如果我们在寻路的过程中，不光记录当前的花费时间，也记录当前已经买到的鱼呢。考虑到题目限制，最多只会有10种鱼，按位储存是一个好的选择。

但是同时记录花费的时间和买到的鱼的种类，下一条最优路径要怎么决定呢？好像还是有点问题，最好是，下一条最优路径，只由花费时间决定就好了。

那，如果将当前已经买到的鱼，扩展成为节点的一部分呢？也就是说，每个节点是一个二元组，[商店标号，买到的鱼]，这样就只由花费时间决定了，可以用Dijkstra算法求出起点[1, 0]到每个节点的最少花费时间。

最后，对于所有商店N上的节点，两两比较，假设是i和j，如果节点i买到的鱼和节点j买到的鱼合起来是全部的鱼，那么到这两个节点的最少花费时间里的较大值就可以作为答案的备选，而所有备选中的最小者，就是答案了。

关于Dijkstra算法的思想，之前已经介绍过，见[这里](../Dijkstra-Reach2)。但是此题用了堆（优先队列）来找到下一个能够确定最短距离的节点。

代码见[solve.php](./solve.php)