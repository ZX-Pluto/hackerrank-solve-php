# Jogging Cats
原题见[这里](https://www.hackerrank.com/challenges/cat-jogging/problem)

夏天到了，大猫和小猫胖了胖了胖了，它们准备慢跑减肥。

城市由N个街区组成，有M条无向道路连接它们。喵子们慢跑的路线必须是个4街区环线，也就是，从街区A出发，沿着4条不同的道路经过不重复的街区B,C,D，最后回到街区A。

问，一共有多少种不同的环线。

# 分析
这个题目，说实话，看了编辑的解答之后，我没想到是这样去卡时间复杂度的。

从一般情况来说，这应该是一道广度优先的遍历算法，将可能的环线都遍历，但是，非常糟糕，时间复杂度超了。

那么，用什么样的方法，能够保证一定的时间复杂度呢？答案是：分治。将点（街区）按度数（连接的道路数）划分成大小两个集合，再将所有环线根据不同集合组合的方式分别计算数量，最后再归总。

度数的分界点选择很重要，但说实话，我也不知道为什么选择这个数，它就是T =（N的1/3次方），大于它的点，标记为大点，否则为小点。

将点分数之后，根据组成环线的点的大小，可以将环线分成六类：
* 4小。
* 1大3小。
* 2大2小，两个大点相连，同样的，两个小点也相连。
* 2大2小，两个大点不相连，同样的，两个小点也不相连。
* 3大1小。
* 4大。

下面针对不同种类说明求解方式及对应时间复杂度。

## 4小
这个就是直接暴力莽一波。对于每个小点A，B和C是与A相连的小点，则再找另一个不是A的小点，同时与B和C相连，每种这样的情况就是一个环。

实际处理时，B和C可以按照B < C的方式遍历，减少重复计算。而找同时与B和C相连的点，则是针对B的相邻小点遍历，再检查是否也与C相连即可。

时间复杂度方面， 应该是 小点数量 * 小点相邻点数量 * 小点相邻点数量 * 小点相邻点数量。

注意， 小点数量 * 小点相邻点数量， 对应的是全部小点相连的边的量级，即O(M)，而根据小点的定义，每个小点的相邻点数量都小于等于T，因此最终时间复杂度为O(M) * T * T = O(M* (N的2/3次方))。

## 1大3小
这个其实跟4小是类似的，就是最后的找小点换成找一个大点，同时与B和C相连。

因此，时间复杂度也类似。

## 两个辅助数组
在继续讨论剩下的情况之前，需要引入两个辅助数组，帮助记录一些东西，以便于处理。

这两个数组A和B的含义如下：
* A[X][Z]: X和Z都是大点，A[X][Z]表示从X出发，经过任一其他大点，再从其到达Z，所有这样的路线总条数。
* B[X][Z]: 类似于上面，X和Z都是大点, B[X][Z]表示从X出发，经过任一其他小点，再从其到达Z，所有这样的路线总条数。

这两个数组能够帮助以下三种情况：
* 4大。注意，每一个4大的环，假设取其中两个相对的点S和T，那么，另外两个点肯定都是被计算在A[S][T]中的。也就是，若固定两个大点S和T，则以它们为相对点的4大环数量为(A[S][T] * (A[S][T] - 1))/2。想想排列组合公式应该能明白。
* 3大1小。对于任一小点，对于每种与其相连的不同大点S和T组合，都能够组成A[S][T]个这样的环。
* 2大2小，两个大点不相连。与4大类似，就是(B[S][T] * (B[S][T] - 1))/2。

## 2大2小，大点相连
这种情况，又是直接莽，对于任一小点S，遍历其相邻小点T，然后对S相邻的任一大点U和T相邻的任一大点T，若U和T相邻，则组成一个环。

时间复杂度方面，跟4小是类似的，O(M* (N的2/3次方))

## 2大2小，大点不相连
在两个辅助数组中已经讨论了怎么处理。

时间复杂度方面，就是求B数组的时间复杂度，求法为：对每个小点，遍历其相邻的不同大点X和Z，将B[X][Z]加1。

因此是小点数量 * 小点相邻点数量 * 小点相邻点数量 = O(M * (N的1/3次方))

实际的环数在求B[X][Z]的过程中可以一并求出来。

## 3大1小
在两个辅助数组中已经讨论了怎么处理。

时间复杂度方面，首先是求A数组的时间复杂度。求法为：对每个大点，遍历其相邻的不同大点X和Z，将A[X][Z]加1。

因此是大点数量 * 大点相邻大点数量 * 大点相邻大点数量 = O(M * M / T)，但我觉得这个值是有可能比O(M* (N的2/3次方))要大的。

然后对小点遍历，再遍历其两个相邻大点， 即小点数量 * 小点相邻点数量 * 小点相邻点数量 = O(M * (N的1/3次方))

## 4大
在两个辅助数组中已经讨论了怎么处理。

时间复杂度方面，与3大1小是共用的同一个数组。

实际的环数在求A[X][Z]的过程中可以一并求出来。

具体代码见[solve.php](./solve.php)