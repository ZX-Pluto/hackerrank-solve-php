# Frog in Maze
原题见[这里](https://www.hackerrank.com/challenges/frog-in-maze/problem)

n * m，n行m列的棋盘，棋盘上的每个方格可能是如下之一：
* 空白格，可以落脚
* 起始格，跟空白格一样，只是标识为初始位置
* 墙，不可落脚
* 出口，可以落脚，到达则算胜利
* 炸弹，可以落脚，到达会被炸死，算失败

另外在两个空白格之间可以有一条通道，如果进入其中的一个格，会马上被传送到通道的另一端。

现在一只青蛙从起始格出发，每一步，可以沿着上，下，左，右里面可以通行的任一方向移动一格，问最终胜利的概率有多大。

注意，如果到了一个格，没法再移动了，也算游戏失败。这种情况会出现在被通道传送时，另一端空白格四周都是墙的时候。

# 分析
每个有效（可通行）方格看做一个状态的话，从每个状态转移到另一个状态的概率是固定的。
* 对于空白格，只有一个方向可以通行，则以1的概率转移到那个方向相邻的格。如果有两个方向可以通行，各1/2的概率。
* 对于终点状态，包括出口，炸弹，以及四周都是墙的空白格，此时游戏结束了，因此看作永远留在此方格了，以1的概率转移到自己

状态，随机转移，你有没有想到什么呢？是的，[马尔可夫链](https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/6171383?fr=aladdin)

而带有吸收状态（以1的概率转移到自身），且每个非吸收状态都可到达某个吸收状态的，叫做吸收马尔可夫链。现在要求的就是，求在吸收马尔可夫链中，从某个状态出发，最终到达各吸收态的概率。

这个，如何计算，在wiki里其实讲得比较清楚了，见[这里](https://en.wikipedia.org/wiki/Absorbing_Markov_chain)， 
如果你没法科学上网打不开的话，[这篇文章](http://www.vartang.com/2013/02/%E5%90%B8%E6%94%B6%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/)讲得也不错。

但是或许你还是没明白，我再努力讲一讲好了hhhhhhh

首先，假设一共n个状态，有t个非吸收状态，有r个吸收状态，在构造n*n的转移矩阵时，我们把非吸收状态放在前面，吸收状态放在后面，矩阵可以看成如下的形式：  
Q R  
0 Ir  

其中，左上角Q是t*t的矩阵，是每个非吸收状态到非吸收状态的的转移概率。

右上角R是t*r的矩阵，是每个非吸收状态到吸收状态的转移概率。

左下角的0是r*t的矩阵，每个值都是0，因为这是每个吸收状态到非吸收状态的转移概率，显然，不可能转移，因此都是0。

右下角的Ir是r*r的[单位矩阵](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5/8540268?fr=aladdin)，是每个吸收状态到吸收状态的转移概率。
因为每个吸收状态只可能转移到自己，因此只有对角线上的值是1.

假设从每个非吸收状态，最终到达每个吸收状态的转移概率矩阵是B, 它是一个t*r的矩阵，根据吸收马尔可夫链的性质，它的求法是
* B = N*R。这里的*指的是矩阵乘法，矩阵乘法是啥，应该不用我说了吧……

这里，R就是上面的R，那么这个N又是什么呢？

N是一个t*t的矩阵，它第i行第j列代表的含义是，从状态i出发，在到达吸收态之前，能够到达状态j的次数的期望值。

也就是，假设1步到达的概率是P1,2步到达的概率是P2,3步到达的概率是P3，则期望值为 1 * P1 + 2 * P2 + ... + n * Pn。

这个如何计算，也已经有公式给出了。

* N = (It - Q)的逆矩阵

其中It是t*t的单位矩阵，Q就是之前的非吸收状态之间的转移概率矩阵。

那么就是先求(It - Q)，这个容易，矩阵减法，对应位置相减即可，然后再求它的逆矩阵。

在这里，我用的是初等行变换求逆矩阵的方法。假设要求的矩阵是K，k*k的方阵。
1. 在K右边再增加一个Ik，即k*k的单位矩阵，变成一个新的k * 2k的矩阵L
2. 对整个L做初等行变换，使得左部的k*k的矩阵变成单位矩阵，此时，右部的k*k的矩阵就是K的逆矩阵。

对L初等行变换处理的具体过程如下：
* 依次遍历1,2,3...k，对当前遍历的序号i：
    1. 如果L[i][i]是0，找一个其他行j满足L[j][i] != 0，将行j加到行i上。
    2. 如果L[i][i]不是1，对行i的每一列，除以L[i][i]。这样就保证了L[i][i]
    3. 对于所有其他行j，如果L[j][i]不是0，将行i倍乘-L[j][i]，再加到行j上。这样做，就保证i列除了L[i][i]之外，其他值都是0。

这样整个流程就串起来了：
1. 遍历输入，确定非吸收态，吸收态，及状态转移矩阵，生成Q和R。
2. 生成矩阵(It - Q)
3. 计算上一步矩阵的逆矩阵N
4. 计算B = N*R
5. 对于给定的初态，累加B中此初态到各胜利吸收态的概率，输出结果

具体代码见[solve.php](./solve.php)