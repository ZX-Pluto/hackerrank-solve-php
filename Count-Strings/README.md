# Count Strings
原题见[这里](https://www.hackerrank.com/challenges/count-strings/problem)

这是一道关于正则的题目。

对于R，它是一个有效的正则表达式如果：
1. R是"a"或"b"
2. R是如下的形式"(ST)"，其中S和T也是有效的正则表达式。
3. R是如下的形式"(S|T)"，其中S和T也是有效的正则表达式。
4. R是如下的形式"(S*)"，其中S也是有效的正则表达式。

其中"*"和"|"就跟日常的正则表达式中的含义一样，分别表示“重复0次或多次”和"或"

对于给定的正则表达式R，问能够与之匹配的长度为L的不同字符串有多少个。

# 分析
这道题我放了很久，每每看到就直接跳过，就是因为自动机和编译原理方面不是很擅长。后来想想不能由于这是自己的短板就放任不管，于是猛的研究了下补了相关的知识。

完整的学习和理解了相关内容后，觉得它的各个环节流程主要思想都不难，但是写起来代码长（我这边写了400多行）。

首先，将这个问题划分成三个子问题：
* 正则表达式转NFA，NFA的意思是非确定型有限状态自动机。
* NFA转DFA，DFA，对应于NFA，是确定型有限状态自动机。
* 根据DFA的单步转移矩阵，计算L步能从起点走到有效终点状态的路径数量。

关于自动机，NFA，DFA的含义，我这里就不展开讲了，自动机还是应该学过或自己去了解下的。

## 正则转NFA
像这样的问题，肯定不可能让我们自己去想一个方法出来，必然是站在巨人的肩膀上。

那么，就是著名的[Thompson构造法](https://baike.baidu.com/item/Thompson%E6%9E%84%E9%80%A0%E6%B3%95/22735759)了。

关于它我这里就不讲了，但是需要提一句，文中并没有提怎样算是一个子表达式的开始或结束，也就是什么样的情况需要开始和完成一个子NFA。

通常来说，左括号肯定表示子表达式开始，右括号表示子表达式结束。但是，碰到某些符号时，也表示之前的子表达式需要计算生成新的表达式。
例如 a|b|c|d，在碰到第二个"|"时，应该将前面的a|b计算生成新的NFA，再继续处理。

所以，实际处理的话，最好是将中缀表达式（输入的正则式就是中缀表达式）转换成后缀表达式，去除括号，再进行处理。

考虑到这道题的特殊性，总会有左右括号标识子表达式的开始和结束，这一步就可以省略了，直接根据符号做对应的处理就好。

引入一个中间类型“结果集”，它包括三项，操作符，左子NFA，右子NFA，最终用结果集计算，生成新的NFA。对于结果集，有如下操作：
* 将NFA加入结果集。处理方式是如果左子NFA为空，则作为左子NFA，否则作为右子NFA。由于上面说的这道题的特殊性，不会出现左右都不为空的情况。
* 设置操作符。操作符有三种，连接，或'|'，以及重复'*'。
* 计算。生成并返回新NFA，这个就是Thompson构造法描述的处理过程了。

从前往后遍历正则字符串s，对于每一步translateRegex(index)，返回值是两项[生成的NFA，下一个要遍历的index]具体处理方式如下：
1. 新建结果集resultSet，默认操作符为连接.
2. 当index超出字符串长度时转3，否则：
    1. 判断s[index]的字符：
        * 如果为左括号，递归遍历result = translateRegex(index + 1)，将result[0]加入到resultSet，将index更新为result[1]。
        * 如果为右括号，计算resultSet的值，返回[计算得出的值， index]。
        * 如果是'|'，设置resultSet操作符为'|'。
        * 如果是'*'，设置resultSet操作符为'*'。
        * 如果是'a'或'b'，新增一个单步转换的NFA，加入到resultSet。
    2. index自增1，再继续转第2大步。
3. 计算计算resultSet的值，返回[计算得出的值， index]。

## NFA转DFA
这个，同样的也是有现成的方法的， 叫[Powerset construction](https://en.wikipedia.org/wiki/Powerset_construction)，中文翻译叫子集构造法，但是我没找到相关的百科文档啥的。

首先，在Thompson构造法中应该有看到这个ε，表示空串，即不接受任何输入就发生转移。

那么对于某个状态s，ε-Clouse（s）的结果就是从s能够通过任意次空串转移到达的全部状态的集合。

再进一步扩展，对于一个状态集S，它的ε-Clouse（S）就是S中每个状态s的ε-Clouse(s)结果集合的并集。

Powerset construction就是建立在ε-Clouse的基础上，输入为NFA，最终构造生成DFA，步骤如下：
1. 对于NFA的起点状态，计算其ε-Clouse, 生成的集合对应DFA的起点。DFA中的每个节点都对应NFA中的一个唯一子集
2. 对于目前DFA中每个未遍历过的节点t：
    1. 将t记录为已遍历。
    2. 对于每个有效输入字符s，计算其t对应的NFA中子集各状态根据s进行一步转移能够到达的NFA状态集，假设为M，再计算M对应ε-Clouse，假设为N。
        * 如果N已经有对应的DFA节点，则增加边，t碰见s后会转移到此节点。
        * 如果N还没有对应的节点，新增一个新节点n，增加边，t碰见s后会转移到n。
    3. 继续转第2大步，直到全部节点都已经遍历过为止。

这样就得到了DFA

## 根据DFA单步转移矩阵计算结果
DFA其实是一张状态转移图，那么单步转移矩阵matrix是怎样呢？就是如果状态A能够一步到达状态B，则对应matrix[A][B] = 1，否则为0.

而如果matrix自乘（用矩阵乘法），得到的就是两步转移矩阵，此时matrix[i][j]代表的含义是，从状态i开始，通过两步转移，能够到达状态j的路径总数。

依此类推，n步转移矩阵就是通过n步转移，某个状态能够到达另一状态的路径总数。

而最后要的结果，就是n步矩阵中，DFA起始状态到达终止状态的路径总数之和。

这里的优化就是不是真的一步步的往上乘，而是计算出2步转移，4步转移，8步转移，16步转移等等，再组合成n步转移。这个是二进制的基本原理:)

具体代码见[solve.php](./solve.php)，我真的写了好长好长……