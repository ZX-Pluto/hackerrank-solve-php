# Inverse-Rmq
原题见[这里](https://www.hackerrank.com/challenges/inverse-rmq/problem)

RMQ, Range Minimum Query, 翻译作范围最小值查询，是这样一个问题：给定长度为n的数组，n为2的整数次方，数组内元素各不相同。
再给定m个查询，每个查询要查数组[L(i), R(i)]范围内的最小元素。

非常有效且有名的一种解法就是使用线段树，在这里使用的线段树是满二叉树，一共2n-1个节点，叶节点表示原始数组中的元素，然后每个非叶节点，记录其子树覆盖的原始数组范围内的最小值。

通常，线段树的表示方法不用真的用树结构这么麻烦，而是使用一个长度为2n - 1的数组。
对于数组中的第i个节点而言，它的左子节点（如果存在），对应的是数组中的第2i + 1项，它的右子节点对应的是数组中的第2i + 1项。

例如，对于原始数组[1, 2, 3, 4]，对应的线段树A = [1, 1, 3, 1, 2, 3, 4]。构造过程如下：
1. 原始数组占据最右侧的4个节点。
2. 对于3, 4两者中更小的是3， 对于1, 2两者中更小的是1， 它俩分别作为3, 4和1, 2的父节点，
3. 对于1, 3更小的是1，作为1,3的父节点， 由于只剩下一个数了，它就是根节点。

所以,A[0] = 1， 它的左右子节点 A[1] = 1, A[2] = 3， 它们的子节点A[3] = 1, A[4] = 2, A[5] = 3, A[6] = 4。

现在，给你了一个长度为n的数组，然后你构造好了相应的线段树数组A。

不幸的是，有个邪恶的人修改或是打乱了数组A中的元素。

问，给定被捣乱之后的数组A，能否通过交换数组中的元素，还原成一个有效的线段树数组？

如果不能，输出NO，如果能，输出YES以及还原之后的数组，取数组排序最小的那个。

# 分析
通过打乱数组元素顺序得到，那就需要将线段树还原成原来的样子。

假设n = 2的k次方，则此线段树一共有k+1层，令最底的为第1层，最高的为第k+1层。

很显然，第k+1层只有一个元素，就是原始数组中最小的那个。而且要还原成排序最小的数组的话，它也应该出现每一层的最左端，也就是，一共会出现 k+1次。

第k层，有两个元素，除了原始数组中最小那个之外，另一个元素也会在更低的每一层出现，而且出现位置始终是它的子树中的每一层的最左端。

我这里就不继续讲其他层了，直接说结论吧，如果一个元素出现i次，那么最终它能够往上走到第i层。

所以，要做的第一项检查就是，元素的出现次数统计是否符合规则。

在符合规则的情况下，再从顶向下，填充每一层的元素。

第k+1层，不用说了，就是最小的元素。

第k层，第一个是最小的元素，第二个是唯一的出现k次的元素。

下面使用动态递推。假设已经放置好了第i层的元素，则对于第i-1层，设停止在此层的元素集为S[i-1]，
则从左至右遍历第i层的元素，每个元素都选择在S[i-1]中首个比其大的，并从S[i-1]中移除。

这样就能构建出每一层了。当然，如果某一层构建不出来，那就输出NO。

每一层从左至右遍历并选择首个更大元素时，使用Set维护元素集，使用二分查找是比较合适的，但是，对于PHP而言，官方数据结构中没有类似C++中Set的实现。

于是，我只能参考网上的实现，自己写了个红黑树，来进行处理:(

具体代码见[solve.php](./solve.php)