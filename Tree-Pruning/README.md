# Tree Pruning
原题见[这里](https://www.hackerrank.com/challenges/tree-pruning/problem)

有中文，就不翻译了。

# 分析
说实话这题目我自己是没能想出来的，是看到讨论区有位大佬提点了一句：如果用DFS后根遍历，生成一个队列，再依次决定队列中的每项移除与否，能发现什么规律么？

假设按队列从前往后处理queue[i]表示第i项对应的原始编号， 令dp[i][j]表示前i项，j次移除操作，能够达到的最大权值和。那么针对第i项，当然是二选一，移，或者不移。

如果不移， 则dp[i][j] = dp[i-1][j] + weight[queue[i]]， 即第i项的权值应该加进来。

如果移，则情况有些特殊，因为可能在处理i的时候，其子树节点也被处理过， 此时应该还原子树的移除（因为会被移除i覆盖）。
但是，不用真的去往前遍历寻找所有已处理的子树元素，有个更好的办法。

假设subTreeNum[t]表示节点t及其子树的元素总数， 如果t在queue中是第m项， 则第m - subTreeNum[t]项是最后一项不是t的子树的元素， 换句话说，从m - subTreeNum[t] + 1到m这个范围区间， 就是t的子树及t的全部元素了。

所以，如果移除的话，则dp[i][j] = dp[i - subTreeNum[queue[i]]][j - 1]，即所有子树元素都不需要再考虑了，回退到遍历其子树之前的最后一个元素。

那最终就是，分两步走：
1. DFS遍历，求每个元素的子树数量，及生成处理队列。
2. 对处理队列按上述思路跑动态规划，得到最终结果。

但是，实际处理起来有个问题，如果dp用二维数组的话，内存会超。

那么换一下定义，令dp[i][j]表示前i项，<= j次移除操作，这样就可以只用一个一维数组arr[i]保存，初始对应j = 0, 每轮遍历，j自增1，最终arr[i]表示前i项， <= k次移除，返回arr[n-1]即可。

具体代码见[solve.php](./solve.php)