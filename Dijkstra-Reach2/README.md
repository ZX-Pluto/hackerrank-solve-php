# Dijkstra: Shortest Reach 2
原题见[这里](https://www.hackerrank.com/challenges/dijkstrashortreach/problem)

典型的最短路问题，给定顶点，边，和源点，求源点到其他顶点的最短路径长度。

# 分析
'很显然的，题目都说了，用迪克(杰)斯特拉算法就好，至于这算法是啥，自己搜一下。下面直接给出代码。'这样？  
不，我每每看见这样的文章，都会骂一句。我要已经看明白了算法，还要看你这文章作啥，就是想让你给翻译翻译解释解释啊。  
我从05年大一下学期离散数学第一次接触到它以来，这十多年无数次忘记， 又无数次看算法描述回忆起来。那么，何不自己写个讲解呢？哪怕之后又忘了，自己跟自己的思路会更容易一点吧。  
  
Dijkstra算法主要解决的问题是，“从一个顶点到其余顶点的最短路径长度”。它从起始点开始，每一步都求出到一个可达顶点的最短路径。  
先讲算法实现原理， 再讨论一下正确性的问题。至于怎样想到这个算法，这个我就没法回答了。 

## 算法思想
设所有顶点集合为V， 当前已经求出最短路径的顶点集合为S， 起始点为s。
1. 初始化S仅包含起点s。
2. 选择一个不在S中的顶点t加入S， 满足以下条件：
    1. 从s到t的路径，中间仅经过S中的顶点。
    2. 此路径为所有满足上个条件中长度最短的那条。
    此路径就是s到t的最短路径。
    不断执行，直到没有顶点可以加入S为止。

下面来证明这样找到的每条路径就是最短路径。  
首先，第1次选择的路径对应的顶点t，肯定是最短路径。因为第1次选择时，S仅包含起点s，选择的只能是与s相邻且长度最小的一条边。  
假设前i次选择的都是最短路径，第i + 1次选择了路径P和顶点j。  
如果P不是s到j的最短路径， 假设Q才是最短路径， Q路径为 s -> q1 -> q2 -> ... -> j，则路径中必然存在一个顶点k，使得k不在集合S中。
如果不存在这样的顶点， 则q1, q2, q3 ... qn都在S中， 那么路径Q和顶点k才是应该选择的点， 与当前选择矛盾。  
而对于所有出现在Q路径中且不在集合S中的顶点而言，假设k'是出现的第一个， 那么跟上面一样， 从s -> q1 -> q2 -> ... -> k'才是应该选择的点， 依旧矛盾.

## 算法实现
定义一些变量。
* s, 表示起始点
* `E[i][j]`， 表示连接顶点i和顶点j的边的长度， 如果不存在这样一条边，则长度为无穷大。 `E[i][i]` = 0
* `D[i]`， 表示当前求出的从起始点到顶点i的路径长度，且中间只经过已求出最短路径的顶点。这个值会在遍历过程中动态变化。 如果起始点无法到达顶点i，则长度为无穷大。
* `P[i]`， 顶点i是否已经求出了最短路径。

算法实现过程如下：
1. 初始化, `P[s] = true`, 对于每个顶点i，设置 `D[i] = E[s][i]`。
2. 从D中选择一项t，使得t满足以下条件
    * `P[t]` 为false
    * 对于所有`P[i]`为false的项i，都有 `D[t] <= D[i]`
    即选择未求出最短路径的顶点中，当前路径长度最小的一项。
    如果找不到这样的项，结束。否则转3。
3. 设置`P[t] = true`，对于所有`P[i]`为false的项i，做以下操作
    * 如果`D[i] > D[t] + E[t][i]`， 则设置`D[i] = D[t] + E[t][i]`， 表示找到了一条更短的s到i的路径。
    再转2.

最终，数组D就是全部最短路径长度。

## 对于此题的特殊处理
根据题意， 两个顶点之间可能存在多条边，然而，实际计算的时候，只需要用到最短的那边条。   
如果两个顶点之间的边有很多，全部读取再一次性作为函数输入，则会占据额外的存储空间。题目自带的输入处理就是这样， 会导致Test case7 内存超出。    
因此，我这里作了一个修改， 在读数据时直接处理邻接数组， 再将邻接数组作为参数传入。

具体代码见[solve.php](./solve.php)