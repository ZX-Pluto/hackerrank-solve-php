# Task Scheduling
原题见[这里](https://www.hackerrank.com/challenges/task-scheduling/problem)

有一系列任务需要你完成，对于每个任务i，都有两个值，M[i]，表示完成它需要的时间，D[i]，表示它应该在某个时刻之前完成。

例如M[i] = 3, D[i] = 6，表示完成此任务需要3分钟，而它最晚应该在第6分钟结束前完成。

对于每个任务，不是一定要一次性完成，可以随意切换，做到半路，转而去做其他任务。

非常不幸的是，不一定所有任务都能按期完成。所以现在，你需要合理分配时间，使得最长延期时间最小。

也就是假设每个任务的延期时间delay[i] = 完成i的时刻 - D[i]，要使得delay数组的最大值最小。当然，如果没有延期，delay[i] = 0

给定输入数组，要求输出的第i行是：如果对前i行的全部任务进行最优化安排，所求出的最长延期时间的最小值是多少。

# 分析
## 我的解法
这道题被归在了“贪心法”的分类里，那么，贪心贪在哪？答案是，贪在总是优先完成deadline值最小的任务。

令任务i对应的完成时间为E[i]。

对于任意两个任务i和j，设i对应的deadline值更小，即有D[i] < D[j], 下面证明E[i] < E[j]才是正确的做法。

用反证法，假设E[j] < E[i]，则对于i和j两个任务来说，i拥有更长的延期时间，因为 E[j] - D[j] < E[i] - D[i]。

如果交换一下完成这两个任务的顺序，令新的完成时间为E'，则有 E'[i] < E'[j] = E[i]，新的延期时间分别是 E'[j] - D[j] 和 E'[i] - D[i]。
* 由于E'[j] = E[i], D[i] < D[j]，因此E'[j] - D[j] < E[i] - D[i]。
* 由于E'[i] < E[i]，因此E'[i] - D[i] < E[i] - D[i]。

也就意味着，如果交换一下完成顺序，则两个新的延期时间都比原有的延期时间中的大者要小。如果对所有未顺序完成的任务都这样处理，有可能会降低最长延期时间的最小值，并且最坏也至少不会让它增大。

所以，我们得到这样的结论：
* 对于任意任务i，它的延期时间delay[i] = (计划完成时刻 <= D[i]的所有任务需要用时之和) - D[i]

同时可以观察得出，如果多个任务的计划完成时刻相同，它们可以合并成一个，将对应的需要用时加在一起即可。这个我这里就不说明了，留给你思考为什么。

那么，对于一个固定的任务列表，就很容易得到一个简单粗暴的做法：
1. 按计划完成时刻D进行排序，合并相同的项。
2. 从前往后遍历，依次计算延期时间，最终返回最大值。

然而，现在有这么一个问题，要处理的任务列表不是固定的，而是每次都多加入一个任务，怎么办呢？

很直观的办法当然是，将其插入到数组中适当的位置（或是与数组中的某项合并，如果对应的计划完成时间相同），然后从此位置从前往后再遍历计算一遍（因为插入它不会影响完成在它之前的任务所需的时间）

这样做，当然，是正确的，但是，不够快，提交会timeout。

所以，如何优化下，进行加速。

在上面的做法里，我只是记录了最大延时时间，在下一个任务插入时，也只是遍历比较有没有产生新的更大值，忽略了另一个属性，就是它对应的计划完成时间是多少。

思考之后， 在新加入一个任务时，可以做如下处理：
1. 如果当前最大延时时间为0，正常插入处理。
2. 如果当前最大延时时间大于0，与对应的计划完成时间比较。
    * 如果新任务的计划完成时间小于等于当前最大延时时间对应的计划完成时间，则当前最大延时时间 = 当前最大延时时间 + 新任务所需时间
    * 否则，正常插入处理。

正常插入处理的两种情况肯定没有任何问题，那么剩下的情况，为何这样得到的新的最大延时时间就是对的呢。

假设原先的最大延时时间为a，对应项的计划完成时间为D[t]，新加入的任务，计划完成时间为D[i]，所需时间为b。
1 对于所有计划完成时间小于D[i]的项，它们的延时时间不受影响，因为它们要在新的任务之前完成，跟之前的处理一样，小于等于D[t]
2 对于所有计划完成时间大于D[i]的项，它们的延时时间 = 原有延时时间 + b，因为它们要在新任务之后完成，与之前相比，就多了一项任务要先完成。因此D[t] + b仍是最大的
3 对于新加入的任务本身，如果之前已经有计划完成时间为D[i]的项，则可以看做是情况2。否则，新任务的延时时间 = 它的前一项的延时时间 + b - (D[i] - 它的前一项的计划完成时间)，依旧小于D[t] + b。

所以这样的做法是正确的。具体代码见[solve_my.php](./solve_my.php)

## 另一种解法
看了出题者自己的解答说明之后，明白了另一种思路，不过TA的说明我看起来有些不太明白，最终还是自己想清楚了，也写在这里。

考虑一下，对于两个任务i和j，假设D[i] < D[j]，要比较两者的延期时间E[i]和E[j]谁更大，有没有比从头开始依次遍历更快的计算方法呢。

有，将如下两者进行比较即可：
* 计划完成时间大于D[i]，且小于等于D[j]的全部任务，它们的所需时间之和。
* D[j] - D[i]

如果前者大，则E[j]更大，否则E[i]更大。因为
```
 E[j] = 小于等于D[j]任务所需时间之和 - D[j]  
      = (小于等于D[i]任务时间之和 + 大于D[i]小于等于D[j]任务时间之和) - D[j] - D[i] + D[i] 
      = (小于等于D[i]任务时间之和 - D[i]) +  (大于D[i]小于等于D[j]任务时间之和 - (D[j] - D[i]))
      = E[i] + (大于D[i]小于等于D[j]任务时间之和 - (D[j] - D[i]))
```

理解起来就是，在D[j] - D[i]这段时间内，能不能完成大于D[i]，小于等于D[j]的全部任务，能的话说明这段区间内任务不会导致j任务进一步延迟。

那么，可以保存当前每个任务D[i]与前一个任务之间。

而如果插入一个新的任务，导致产生了新的最大延期时间，情况会是怎样的呢？

假设之前最大延期时间对应的计划时间为D[m]，插入的新任务为i，新的最大延期时间对应的计划时间为D[n]，那么有：
* D[i] > D[m]，之前在“我的解法”里已经讨论过，如果D[i] <= D[m]则D[m]还是对应的最长延期时间项。
* D[n] >= D[i]
* m和n满足上面说的会导致任务延迟的条件。

每次插入的时候，只要从i开始，依次向后遍历，找有没有产生使得D[m]与遍历项之间时间被填满（即会进一步延迟）的情况即可。

同时，通过观察，可以发现以下两点：
1. 如果对于任务i和j，D[i] < D[j]，D[i]与D[j]之间已经被填满，则只需要遍历D[j]即可，因为无论新的任务插入在哪，都不会让已经填满的任务消失。
2. 如果新任务的deadline < D[i] < D[j]，且D[i]与D[j]之间未被填满，则只需要遍历D[j]即可，因为新的任务没有填在D[i]和D[j]之间，不会影响它们之间的延期时间大小关系。

这样就可以进行优化的处理了，维护一个有序数组，数组每一项由两个值组成，第一个值是计划完成时间，第二个值是与前一项之间已经被填充的时间，按计划完成时间排序。

在插入新任务时，如果导致两项之间时间被填充满，则将前一项从数组中移除，并更新后一项与新的前一项之间已被填充的时间，如果依旧被填充满，则继续向前遍历。

这样一来，数组的第一项始终对应的是当前最大延期时间的项，而它的第二个值超出第一个值多少，当前最大延期时间就是多少，因为第一项第二个值的含义就是“从起始开始，到完成当前项为止，需要花费的总时间”。

具体代码见[solve.php](./solve.php)