# Flipping the Matrix
原题见[这里](https://www.hackerrank.com/challenges/flipping-the-matrix/problem)

给定一个 2n * 2n的矩阵，你可以将任意一行或任意一列做翻转，翻转次数不限，目标是使左上角的 n * n子矩阵的元素之和达到最大。

现在给定矩阵大小和每个元素的值，输出得到的最大子矩阵元素和。

# 分析

对于矩阵中初始的任意位置i, j，它最后能够到达的位置是有限的，只可能是[i, j], [i, 2n - 1 - j]，[2n - 1 - i, j],[2n - 1 - i, 2n - 1 - j]其中之一。

这是由于翻转操作的性质决定的，也不需要证明吧，以左上角[0, 0]为例代入，它不管怎么翻转，最终都只能是位于四个角之一。

那么，猜测一下，有没有可能最后的最大元素之和，就是取每个这样的一组四个位置中最大的元素，再将和相加呢。

答案是，是的！

需要证明的是，对于左上角矩阵中的位置[i, j]，可以经过翻转，将其能够到达另外三个位置的值与其交换，同时保持左上角矩阵中其他的值不变。

首先考虑与[2n - 1 - i, 2n - 1 - j]交换的情况。可以通过以下三步达成：
1. 将第j列翻转，此时原左上角第j列的元素都到了左下角。在此列，原第i行的元素被换到了第2n - 1 - i行，因此原[i, j]现在到了[2n -1 -i, j]。
2. 将第2n - 1 - i行翻转。此时将初始[i, j]换到了[2n - 1 - i, 2n - 1 - j]，将初始[2n - 1 - i, 2n - 1 - j]换到了[2n -1 -i, j]。
3. 将第j列翻转，此时与第1步对称，原左上角第j列的元素（除了第i行外）又回到了左上角，初始[2n - 1 - i, 2n - 1 - j]换到了[i, j]。

这样就完成了交换，并且左上角其他的元素保持不变。

而对于[i, 2n - 1 - j]，可以先翻转第2n - 1 - j列，将其换到[2n - 1 - i, 2n - 1 - j]的位置，而此次交换没有影响左上角。
接下来，继续按照上面[i, j]与[2n - 1 - i, 2n - 1 - j]交换的操作即可。

对[2n - 1 - i, j]，也是类似的操作，先翻转第2n - 1 - i行，换到[2n - 1 - i, 2n - 1 - j]的位置，再操作即可。

知道了这样操作的正确性，其实算法是很简单的。对左上角的n * n个位置进行遍历，对每个位置，都取它以及能交换到的位置，这四个位置中的最大元素，将这些最大元素相加即可。

具体代码见[solve.php](./solve.php)