# Sherlock's Array Merging Algorithm
原题见[这里](https://www.hackerrank.com/challenges/sherlocks-array-merging-algorithm/problem)

给定一个数组集合V，其中的V[1],V[2],V[3]...都是一个由数字构成的数组。

Sherlock打算把这若干个数组合并成一个数组M，它使用的算法如下：
1. 令M为空数组
2. 令 k = V中数组数量
3. 只要V中还存在非空数组，做以下操作：
    1. 令T = [](空数组), i = 1
    2. while i <= k:
        * 如果V[i]非空，移除其中首个元素并将其加到T中。
        * i = i + 1
    3. while T非空
        * 移除T中最小的元素并将其追加到M中
4. 返回M

现在的问题是，给定最终的数组M，问原始V有多少种可能不同的组成方式。

# 分析
首先，可以想到，先按V中包括非空数组的个数分类，分别是1, 2, ... n。

然后，对于上述中的任意一种，假设非空数组个数为i，能够组成的情况是，每个数组的第一个元素固定，再来决定后面的元素。

注意，这里的第一个元素固定，意思是它们不再进行排列，而是M[1]作为V[1]第1个元素，M[2]作为V[2]第1个元素，M[3]作为V[3]第1个元素，依此类推。

为什么不再排列呢？因为排列的话，最后出现的集合是会有重复的，最后还得去重。

举个例子，现在将M[1]作为V[2]第1个元素，M[2]作为V[1]第1个元素，其他保持不变，最终构成的每个V，跟M[1]作为V[1]第1个元素，M[2]作为V[2]第1个元素所组成的V是一一对应的，就只是V[1]和V[2]交换了一下而已。

所以，首个元素固定不用排列，只排列后面的元素即可。而后面的每一轮，元素要怎么排列呢，根据组合公式，就是C(当前轮可放的数组数, 当前轮选择的元素数)。

要注意，当前轮可放的数组数是变化的，如果一个数组在之前的轮次已经没有再放入元素了，则此轮它是不可放的。

同样的，当前轮能够选择的元素数，也是有限制的，必须是原数组中的一段单调递增的子数组。

这样动态规划的递推处理就出来了，假设dynamic(nowSize, nowIndex)表示当前需要决定nowIndex以及之后的数组如何分配，此时可放的数组数为nowSize。其处理方式如下：
1. 如果nowSize为1，那么，显然，只有一种方式，将后面全部元素都按序放入这个唯一数组中，直接返回1。
2. 如果nowIndex等于M的长度，则说明到头了，同样也返回1。
3. 令result = 0, i = 1, while i <= nowSize:
    * 如果从nowIndex开始的连续i个元素是单调递增的，则result = result + C(nowSize, i) * dynamic(i, nowIndex + i)，这就是选择好此轮的排列方式，再继续处理下一轮。
当然这里要注意i的界限，让其最多只能取到数组的最后一个元素。
4. 返回result

记住，第一轮元素是固定的，因此不能直接调用dynamic(nowSize, 0)，而是应该分别调用dynamic(1, 1), dynamic(2, 2),dynamic(3, 3)...再对其求和得到最后结果

具体代码见[solve.php](./solve.php)