# KnightL on a Chessboard
原题见[这里](https://www.hackerrank.com/challenges/knightl-on-chessboard/problem)
我们都知道，马走日，象飞田，这里是它们的扩展。  
对于一个n*n的棋盘，假设马每次能走的方式为(a, b)，表示在一个维度上移动a个方格，同时在另一个维度上移动b个方格，不超出棋盘即可。  
比如，假设现在位置是(4, 4)而 a = 3, b = 2， 则以下走法都是可以的。
* (4, 4) -> (1, 2)   -3, -2 
* (4, 4) -> (2, 1)   -2, -3
* (4, 4) -> (1, 6)   -3, +2
* (4, 4) -> (2, 7)   -2, +3
* (4, 4) -> (7, 2)   +3, -2
* (4, 4) -> (6, 1)   +2, -3
* (4, 4) -> (7, 6)   +3, +2
* (4, 4) -> (6, 7)   +2, +3

现在题目要求的是，对于 n*n的棋盘，输出对于所有的(a, b)组合(其中 1<=a,b<n)，从棋盘的(0, 0)走到(n-1, n-1)需要的最小步数，如果没法走到，输出-1.

# 分析
我一开始想岔了，还想着怎么要决定下一步的走法。  
一道中等的题，哪有这么难啊，就是莽，直接广度优先遍历就好了。  
对于每一个组合， 求最小步数的步骤如下：
1. 初始化待遍历集合仅包含起点，将除起点外其他点标识为未遍历，初始化当前步数为0。
2. 如果待遍历集合为空，输出-1，结束，表示走不到终点，否则转3.
3. 初始化一个临时集合temp，对于待遍历集合中的每一项，检查它能一步到达的所有点
    * 如果未被遍历，则加入到临时集合，并标记为已遍历。如果此点为终点，输出 (当前步数 + 1),结束
    * 如果已遍历，什么也不做。
   然后再转2.

注意可以稍做优化， (a ,b)和(b, a)的走法是对称的，只要求其中之一即可。

具体代码见[solve.php](./solve.php)