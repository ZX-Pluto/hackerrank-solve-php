# Snakes and Ladders: The Quickest Way Up
原题见[这里](https://www.hackerrank.com/challenges/the-quickest-way-up/problem)

是根据一个蛇梯棋的游戏想到的题目。

你们小时候有玩过那种丢骰子向前进的棋类么，挺类似的。

每个位置都有标号，起点是1，终点是100，除了正常的节点之外，还有些节点，走到它就“前进到XX”，让你离终点更近，这就是梯子。相对应的，有些节点，走到它就“后退到XX”，让你离终点更远，这就是蛇了。

现在的问题是，假设你能随心所欲的丢出任何骰子点数（1-6），对于给定的梯子和蛇的列表，求到终点所需的最短步数，如果到不了终点，输出-1。

# 分析

虽然这道题的一个好的解法是用广度优先搜索，穷举到达每个位置的最短步数。但是这个我想放在更后面讲，先讲下我自己的一个不那么好的但是也能成功求出结果的算法思路。

俗话说得好，学习优秀的算法思路能够让你少走弯路，而学习普通的算法思路再与优秀的对比，能够让你知道弯路是怎样的，这种经验同样宝贵。

## 我的曲折的算法
我的第一想法是， 如果没有蛇和梯子，那最快到终点要怎样？ 当然是，除了最后到终点的那步，其他每一步，能丢6点就丢6点，因为走得最快。

但是，接下来要加上梯子和蛇，所以，还是需要把每个位置能到终点的最短步数保存起来。

然后再把梯子加进去，让每个梯子起点的最短步数等于终点的最短步数，并依次处理影响到的节点。然后再把蛇加进去，用同样的方式处理。

接下来我发现，第一次保存最短步数时，就可以把梯子加进去，然后第二次再把蛇加进去刷新步数。

这样处理之后，还是有通不过的test case，仔细一看，发现通不过的都是走不到终点的。因为我第一次保存最短步数时没有加入蛇，导致终点是始终可达的。

所以我又单独计算了终点不可达的情况。如果终点不可达，则必然满足以下两个条件：
1. 存在连续6个或更多的节点，它们都是蛇的起点。 这样，没有梯子的话，正常的前进是无法越过它们的。
2. 不存在一个梯子，起点在上述节点之前，且终点在上述节点之后。 这是对上一条的补充，表示即使有梯子，也无法跨过它们。

最终代码见[solve-stupid.php](./solve-stupid.php)

## 正儿八经的广度优先搜索算法
广度搜索的准则如下：
1 从节点1（起点）开始，所有下一步能到达的都是1步可达。
2 假设节点i是k步可达，则所有下一步i能到达的，且之前未遍历过的节点，都是 k+1步可达。

这里需要增加一个转换，将“到达的节点”转成“真正到达的节点”，也就是对应蛇和梯子，当走到蛇头时，会自动到蛇尾，因此真正到达的节点就是蛇尾，对梯子也一样。而正常的节点，真正到达的就是自己。

代码见[solve.php](./solve.php)