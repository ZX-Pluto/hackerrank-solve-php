# Jeanie's Route
原题见[这里](https://www.hackerrank.com/challenges/jeanies-route/problem)

N个城市，N-1条路，任意两个城市都可达，每条路都有一个距离。

现在有K封信，要送往K个不同的城市。

Jeanie可以从任意1个城市开始，问将所有信都送到，所需走过的最小距离是多少？

# 分析

看到这题，我的第一反应是，找一条以K个城市中的2个城市为起点和终点的距离最长的路径，然后其他的城市都从这条路径上离得最近的城市走过去再走回来。

但是，为什么这样的结果就是对的呢？

首先，距离最小的路径，一定是以K个城市中的2个作为起点和终点。假设起点s不在K个城市中，那么对于此路径，假设路径上第1个到达的城市为a。
那么，将s到a的这一段去除，以a作为新的起点，后面的走法保持不变，则形成了一条距离更小的路径。类似的方法可以证明要以K中的某个城市作为终点。

然后，题目中给的是树状图，在不走重复路的情况下，从任意城市a到b的路径只有一条。

假设起点为s，终点为e，则距离最小的路径，一定也要经过s到e的上述路径上的每一个城市。

那么对于其他需要投递的城市，要么在此路径上，要么必然从此路径上的一个城市a出发，投递结束后再回到城市a。

对于不在此路径上的任一城市b，由于从起点s出发且必须经过b，而s到b的最短路径也只有一条且一定与s到e的路径有公共部分，公共部分的最后一个城市就是对应的城市a。

而到达b后，由于最终需要到达e，因此必须从b再走到e，同样的，最短路径只有一条，且必须经过a。因此可以看作从a出发，投递结束再回到a。

这样，对于上述每一条从a到b的路径，其上面的边都至少需要经过两次，过去一次，回来一次。那么如果有另一个待投递城市c，也要从a过去再回来。
而a->b与a->c有公共路径的话，则公共路径依旧只需要经过两次，因为可以在它们公共路径的最后一个城市d分岔，分别走d->b->d和d->c->d，是的，就跟主路径s->e分岔的过程是一样的，递归处理。

所有岔路上的边都需要经过两次，而主路上的边至少需要经过一次。因此最小距离 = 所有岔路边距离之和*2 + 所有主路边距离之和。

那么，为什么找一条距离最长的主路，求得的最小距离就是全部走法中最小的呢？

换个思考方向，假设上面是问题一，现在问题二的要求是，从某个城市u出发，投递完全部城市，最后再回到u。

首先对于K中的任意两个城市a和b，都可以看作会从a走到b，或是从b走到a。

然后，对于a和b之间的最短路径，每条边都要走2次。

假设a或b其中一个是u，那么由于是从u出发再回到u，则肯定包含u->a->u或u->b->u的路径。

否则，假设u->a和u->b的公共路径中最后一个城市是c，则有c->a->c和c->b->c，而这两段合起来，就是a->b->a。

而且同样的，按照上面说的有公共路径，就用分岔走法，每条边也不需要走超过2次。那么由于任意a和b之间的边都是走2次，所以，无论从哪个城市u出发，最后再回到u，最终走的距离都是一样的。

回到之前的问题一，每一种走法都可以看作在问题二结果的基础上，再减去起点到终点的距离。那么，当然，如果起点到终点的距离最长，结果就是最小的。

## 我的不那么优化的代码
虽然思路原理是一样的，但是实际做起来，我的写法可能没有那么优化。因为我把它拆成了三步。

第一步，是找到最长路径，确定起点和终点。

第二步，是从起点出发，找到从起点到每个其他待投递城市的路径。

第三步，遍历起点到其他待投递城市路径上每一条边，未遍历过的则加上其距离*2。最后再减去最长路径的距离，得到结果。

第一步找最长路径的具体做法如下：
1. 将整个图当作一棵树处理，每个城市需要记录一个额外信息二元组：[以此城市为起点，到子树中需要投递的城市中，距离最长的城市, 前者对应的距离]。最长路径用三元组进行记录：[最长路径的长度，起点城市，终点城市]。
2. 初始化所有城市额外信息为空，最长路径为[0, 0, 0]。
3. 从城市1开始遍历，对城市i遍历处理过程如下：
    1. 初始化城市i的子节点信息数组为空
    2. 对城市i连接的每个城市j：
        * 如果是从j遍历过来的，跳过。
        * 否则，继续遍历j。
        * 如果j的额外信息不为空，或j属于要投递的城市，则i的子节点信息数组增加一个二元组[i到j的子树中距离最大的待投递城市, i到j的子树中所有投递城市距离的最大值]。否则跳过。
            * 如果j的额外信息不为空，则假设j的额外信息为[ci, di]，此二元组即为[ci, di + i到j的距离]
            * 否则如果j没有额外信息，j属于要投递的城市，则此二元组为[j, i到j的距离]
    3. 如果i的子节点信息数组为空，跳过，说明i子树中没有需要投递的城市。
    4. 如果i的子节点信息数组个数为1.
        * 如果i也是待投递城市，则拿此数组唯一项的二元组第二项（即i到子树中待投递城市的最大距离）与最长路径距离相比，如果大于最长距离，则将最长路径三元组更新为[二元组第二项，i，二元组第一项]，说明最大距离就是节点i到其子树中某待投递城市。
    5. 如果i的子节点信息数组个数>=2.
        * 将此数组按二元组第二项从大到小排序。
        * 取排序后数组的前两个二元组，拿其第二项之和与最长路径距离相比，如果更大，则将最长路径三元组更新为[刚刚计算的第二项之和，第一个二元组第一项，第二个二元组第一项]，说明最大距离是节点i的某子树中的一个待投递城市到另一子树中的一个待投递城市。
    6. 设置i的额外信息 = 排序后子节点信息数组的第一项。

最后得到的最长路径三元组就是求出的最大距离，以及对应的两个城市。

第二步找路径没有什么好说的，以起点为根，每次遍历都记录相应的父节点，再继续遍历子节点即可，对于每个节点，沿着父节点到起点，就是相应的路径了。

第三步，就用上了第二步中得到的父节点信息。对于每一个待投递城市进行遍历，遍历过程如下：
1. 如果当前城市已经遍历了，返回。
2. 否则，将距离加上此城市到父节点城市的边的距离*2，再继续遍历父节点城市。

拿第三步求得的距离之和，减去第一步求出的最大距离，就是最终结果了。
        
由于题目自带的框架代码有误，因此必须要做修改，具体代码见[solve_my.php](./solve_my.php)

## 网站编辑给的优化的代码
网站编辑给的代码，就是将我的三步操作在一次遍历中全部完成了，同时找最长路径和将要经过的边距离加入最后结果。

其中的数据结构很巧妙，每个节点记录了当前节点的所有子树中待投递节点的总数。
对于当前节点a时，如果某子节点b记录的投递节点数不为0或小于K，则说明必然有一条从其他待投递节点至b子树中的待投递节点的路径，也就是a->b这条边必须要经过，需要将此边距离加入。

具体代码见[solve_editor.php](./solve_editor.php)