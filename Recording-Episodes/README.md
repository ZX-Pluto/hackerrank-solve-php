# Recording Episodes
原题见[这里](https://www.hackerrank.com/challenges/episode-recording/problem)  
大意就是有一季电视剧，分成若干集播出，每集都会有一次首播和一次重播。
你会想要把最长的连续剧集用设备录下来，比如录下第2集到第10集。  
每一集录首播或重播都没关系，比如第3集录的重播，第4集录的首播。  
录的顺序也没关系，比如可以先播第5集，再录第2集。  
但是你只有一台设备，而且每次必须录完整的一集，不能只录其中的一段。  
现在要你找出能够录的最长连续剧集，输出首末剧集序号。如果最长的情况有多种可能，选开始剧集序号最小的，比如如果能录4-7，也能录2-5，那么就选2-5。

# 分析
这是一个2-SAT问题，所以解法如下……  
才怪！我要是这么写，跟网上那些不讲清来龙去脉的文章有什么区别。所以，从头开始讲。

## SAT
SAT， 全名是 Boolean satisfiability problem，取了中间的satisfiability前三个字母， wiki对应的页面在[这里](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)， 可能需要科学上网才能看到。  
翻译过来的中文名是“布尔可满足性问题”，对应的百科页面见[这里](https://baike.baidu.com/item/布尔可满足性问题/4715567)，似乎就是翻译了wiki大部分内容，但写得我完全看不懂。  
我用自己的语言描述一下好了，只讲本题相关的部分，而且尽量讲详细一点。但鉴于语文水平不高，可能你也会看不懂:(  
    
简单来说，SAT就是给定一组布尔变量x1, x2 …… xn， 和一个由它们构成的布尔公式F，是否能够找到一组取值，使得F的最终结果为true。  
布尔公式包含三种布尔逻辑运算符， ∧表示与，∨表示或, ¬表示非。
例如 F = x1 ∧ x2 ∧ x3， 当x1,x2,x3都取true时， F为true，此问题有解。
而如果 F = x1 ∧ x2 ∧ x3 ∧ ¬x1， 则无解，因为 x1 和 ¬x1不可能同时为真。 
    
那么， 2-SAT又是什么？ 只包含两个布尔变量么？ 要是这么简单就好了。要讲2-SAT，又得引入一个新的概念了， 叫[Conjunctive normal form](https://en.wikipedia.org/wiki/Conjunctive_normal_form),
中文叫[合取范式](https://baike.baidu.com/item/%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F/2459360)，不过我觉得叫“与范式”更容易懂

### Conjunctive normal form(CNF)
一个布尔公式是CNF，则它必须写成这样的形式。  
F = item1 ∧ item2 ∧ item3 ∧ ...... ∧ itemn
其中每一个item必须是单个变量或是单个非变量进行或操作，即
item = t1 ∨ t2 ∨ t3 ∨ ...... ∨ tn， 而每个t是单个布尔变量或单个布尔变量取非，例如 x1, x3, ¬x4, ¬x5

### 2-SAT
有了上面的CNF，2-SAT就好解释了。  
2-SAT就是CNF的每一个item，都包含两项，例如：
F = (x1 ∨ x2) ∧ (¬x3 ∨ x4) ∧ (x5 ∨ ¬x6)  ∧ (¬x7 ∨ ¬x8)

## 题目转2-SAT
对于题目中取连续剧集的要求，假设取第i集到第j集， 那么需满足如下条件：
1. 对于第i集，首播和重播两者必须至少选其一。
2. 对于任意两集，如果有时间冲突，则最多取其中一集。

在这里，用X(2i)表示是否选第i集的首播，X(2i + 1)表示是否选第i集的重播。  
那么对于第1个条件，可以写成 (X(2i) ∨ X(2i+1))。  
对于第2个条件， 假设 i的首播与j的重播冲突，则可以写成 (¬X(2i) ∨ ¬X(2j + 1))。  
    
那么，判断是否可以取到从i到j的连续剧集， 就可以转换成是否能找到使相应CNF为真的取值了。

## 2-SAT转有向连通图
2-SAT可以用[Implication graph](https://en.wikipedia.org/wiki/Implication_graph)表示，我不知道怎么翻译好，它是一种有向图。
在逻辑上，对于2-SAT的每一个item，还有另一种等价的表示方式，那就是"若p则q"，写作 p => q。  
对于前面的条件，可以改成这样的方式：
1. 若未选第i集的首播，则必须选第i集的重播，反之亦然。可写成 ¬X(2i) => X(2i+1)， ¬X(2i + 1) => X(2i)
2. 对于有时间冲突的两集，若选了时间冲突中的一集，则必须不能选另一集。假设 i的首播与j的重播冲突， 可写成 X(2i) => ¬X(2j + 1), X(2j + 1) => ¬X(2i)

对于"若p则q"这样的形式，可以用有向图中p指向q的一条边来表示。  
一个2-SAT问题的布尔公式有解的充要条件是，所有的布尔变量与它的非都不属于同一个Strongly connected component，强连通分量。  
所以，我又得解释下强连通分量是啥……

### 强连通分量
还是先上[wiki链接](https://en.wikipedia.org/wiki/Strongly_connected_component)
在一个有向图中，如果从节点A能够走到节点B，那么对于A来说，B是可达的，而要是与此同时，对B来说，A也是可达的，那么它们俩就是强连通的。   
如果若干个节点，两两是强连通的，而且它们构成了一个极大连通子图（再也找不到一个新的节点与它们都强连通），则这些节点构成一个强连通分量。

所以问题变啊变啊变，现在变成求强连通分量，然后检查所有的X(0), X(1),.... X(2n), X(2n+1)与它们的非会不会属于同一个强连通分量了。

但是，在这里，可以做一些优化，变为只考虑这些布尔变量，而不用考虑它们的非变量。   
对于上面的条件来说，条件2，对应的边，被指向的节点都只可能是某一个非变量。
而根据条件1，任何一个非变量会且仅会指向一个布尔变量，因为所有集数都必须满足条件1。. 
那么，就只需要检查X(2i)和X(2i+1)是否属于同一个强连通分量即可，条件2也可以由条件1继续推导，写成X(2i) => X(t)的形式。

最终算法就这两步：
1. 根据剧集播出时间，判断互斥关系，建立有向连通图。
2. 从左到右遍历，每一步都寻找更大的2-SAT解。

求强连通分量有什么算法没有呢？当然有了，这里我用了[Kosaraju's algorithm](https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm)和[Tarjan's algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm)。  


### Kosaraju's algorithm
不知道为啥百度百科里会写"Kosaraju算法的解释和实现都比较简单"，我是觉得解释起来比较麻烦，特别是“为什么这样能求出强连通分量”。

先讲算法的实现过程吧。
1. 对图中的每个节点，标记为“未访问”状态，初始化一个有序列表L为空。
2. 对于图中的每个节点u，调用Visit(u)，其中Visit(u)定义如下，是一个递归函数：
    * 如果u未访问，则：
        1. 标记u为已访问，
        2. 对u指向的每个节点v(有一条u -> v的边)，调用Visit(v).
        3. 将u插入到L的头部。
    * 如果u已经访问，什么也不用做。
3. 从前往后，依次遍历L中的每个节点u，调用Assign(u, u)，其中Assign(x, y)定义如下，也是一个递归函数：
    * 如果x还没有设置相应的根节点，则
        1. 将x的根节点设为y。
        2. 对于指向x的每个节点z(有一条 z -> x的边)，调用Assign(z, y).
    * 如果x已经设置了相应的根节点，什么也不做。

最终，所有根节点相同的一组节点就是一个强连通分量。

首先，强连通分量要么是单个节点，要么多个节点必然形成环。这个应该比较明显不用证明了吧。
这就表示。对于强连通分量中的任意两个节点，A和B，A必然既是B的父节点，也是B的子节点。

此算法第二步，是使用深度优先遍历，给每个子节点标上相应的序号，然后再给自己标，每标一个，序号+1。有一个重要的性质：
`如果一个节点的某个父节点序号比它的序号小，那么此节点与其父节点形成了环`.  
    
假设此节点为A，因为是使用的深度优先遍历，所以比A序号小的节点，有两种情况：
1. 在A之前遍历，并且没有遍历到A。 即在之前从某个其他节点B开始遍历，直到遍历结束，之后才从另一个节点开始遍历到A。
2. 能从A遍历到的节点。使用的深度优先遍历，就是会保证节点比子节点序号要大。

第一种情况，不可能碰到A的父节点，因为如果碰到了，那么肯定会继续遍历到A，导致A的序号比父节点小。  
那么就只能是第二种情况，而第二种情况表示此节点会是A的子节点，意味着此父节点同时也是A的子节点，那就肯定构成了一个环。

第三步求强连通分量也比较巧妙，从序号最大的节点开始遍历，对每一个未遍历的节点，设为强连通分量的根，反向遍历将所有未遍历过的父节点加入它，就能得到一个强连通分量。这里也有一个重要的性质：
`如果一个节点的父节点还未遍历，则这里形成了环`。
    
假设现在从A开始遍历，那么对于它的任一父节点B， 如果B的序号大于A，那么之前肯定已经遍历过了，因为序号是从大到小遍历。如果小于A，根据第一步的性质，这里就是形成了环。

假设是在从节点T开始遍历，在构建环的过程中遍历到的A，那么对于它的任一父节点B，如果B的序号大于A，有两种情况：
1. 序号小于T的序号，则B是T的父节点，同时序号小于T，则T与B形成环。
2. 序号大于T的序号，则由于遍历顺序是从大到小，肯定已经遍历过了。

这样依次处理，就能求出所有的强连通分量。

完整的代码见[solve-kosaraju.php](./solve-kosaraju.php)

### Tarjan's algorithm
另一种求强连通分量的算法