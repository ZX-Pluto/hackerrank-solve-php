# A stones game
原题见[这里](https://www.hackerrank.com/challenges/half/problem)

有中文翻译，就不重复了，只大喊一句“森森森谁呀！”

# 分析
既然这是一个捡石子的游戏，那么就应该用Sprague-Grundy theorem来解这道题了。

我这里只会简要的说明一下，具体的说明请看[这里](https://www.geeksforgeeks.org/introduction-to-combinatorial-game-theory/)，记得一定要把四篇文章都看完，这样就会了解了。

## 公平游戏
首先，此定理针对的是一个“公平的”双人游戏，所谓公平，有如下几点：
* 两人轮流交替操作。
* 所有的信息都透明。
* 没有随机因素。
* 在每一回合，假如将当前操作者换成对方，所能进行的操作是完全相同的。

像捡石子，就是这样的游戏。而像象棋，就不是，因为一方只能操作红子，另一方只能操作黑子，所能进行的操作是不同的。

## Grundy Number
接下来来说下Grundy Number(又被称作Nimber)。

它是针对最小单个游戏的，这里的最小单个怎么理解呢？就理解成捡石子游戏里的一堆石子好了，而整个捡石子游戏，是由许多堆石子构成的。

在计算Nimber之前，还得引入一个新的定义-Mex。

所谓Mex,是Minimum excludant的简写，翻译即“最小未出现者”，它的定义是，输入一个数字集，返回未在此集合中出现的最小非负整数。

例如Mex({1}) = 0, Mex({0, 1, 3}) = 2

接着Nimber的定义来了，是针对单个玩家的：
* 轮到此玩家时，如果立即就输了，则Nimber = 0。 举个例子，在捡石子游戏中，拿到最后一颗石子的为赢家，则若轮到玩家A行动时，已经没有石子了，那此时Nimber就是0.
* 否则，Nimber = Mex(接下来可能出现的情况的nimber的集合)

拿个例子来说，现在有一堆石子，共n个，双方轮流取，每次取1个或多个，不能不取，拿到最后一个石子的人获胜，来计算Nimber。

假设Nimber的函数定义为Grundy(i)， 注意，这里的i对应的是当前剩余石子数量。至于为什么输入参数是这个，其实，我也……不知道……

第一步，Grundy(0) = 0，就是按照定义的第一条，现在已经没有石子可拿了，立即就输。

Grundy(1)呢？在剩余1颗石子的时候，只有一种选择，就是全部拿掉，而拿掉之后，剩余0颗，也就是Grundy(1) = Mex({Grundy(0)}) = Mex({0}) = 1

Grundy(2)，有2种选择，拿1颗或是拿2颗，分别对应之后剩余0颗和1颗，则Grundy(2) = Mex({Grundy(0), Grundy(1)}) = Mex({0, 1}) = 2

Grundy(3)，3种选择，拿1，2，或3颗，Grundy(3) = Mex({Grundy(0), Grundy(1)， Grundy(2)}) = Mex({0, 1, 2}) = 3

依此类推Grundy(i) = Mex({Grundy(0), Grundy(1)， Grundy(2), ... Grundy(i -1)}) = i

## Sprague-Grundy Theorem
上面说的是针对单个最小游戏的，那么的由它们组合起来呢？比如，有多堆石子。而且，Nimber算出来了，但它有什么用呢？

那现在就是Sprague-Grundy定理上场的时候了。

对于一个由若干个最小游戏组合而成的公平双人游戏，如果两个玩家A和B都足够聪明，那么，轮到当前玩家时，如果所有子游戏的Nimber值异或之后不为0，则最终此玩家获胜，若为0，则此玩家失败。

依旧举个简单的例子，还是以上述的捡石子为例，现在有两堆石子，一堆1个，另一堆2个，拿到最后1颗的人获胜。现在你先行动。

子游戏，自然就是针对每1堆石子拿最后1颗。那么根据上面的计算规则，当前两堆的Nimber分别是1和2， 而 1 xor 2 = 3，因此如果你不出错，你一定会获胜。

而获胜的策略，当然就是，使得在你行动之后，轮到对方时，对方计算出的Nimber值异或之后为0.

还是上面的情况，该怎么操作呢？当然就是，从数量为2的那堆中取1个，然后两堆都剩1个，Nimber分别是1和1，1 xor 1 = 0，而现在轮到对方了，对方必定会输。

虽然有点偏离此题，但还是扩展一下，对于上述规则下2堆石子的情况，可以得出一个结论：如果一开始2堆石子数量不同，则先手胜，否则后手胜。

因为数量不同，则Nimber异或值肯定不为0，只要操作从多的那堆里取，使2堆数目相等，则Nimber异或值就变成0了，接下来无论对方怎么取，都会再次使得2堆数量不等，你再继续使得2堆数目相同的取法。

如此反复，则最终必胜。

## 此题Nimber计算
此题的Nimber，相比上述说的普通取石子，有所不同，因为规则发生了变化，每次至少要取向上取整的一半石子才行。

Grundy(0) = 0, Grundy(1) = 1, Grundy(2) = 2保持不变，但是从3开始就不一样了。

对于3颗石子，必须拿走2颗或3颗，剩1或0，所以 Grundy(3) = 2。依此方案继续推导：
* Grundy(4) = Mex({Grundy(0), Grundy(1), Grundy(2)}) = 3
* Grundy(5) = Mex({Grundy(0), Grundy(1), Grundy(2)}) = 3
* Grundy(6) = Mex({Grundy(0), Grundy(1), Grundy(2), Grundy(3)}) = 3
* Grundy(7) = Mex({Grundy(0), Grundy(1), Grundy(2), Grundy(3)}) = 3
* Grundy(8) = Mex({Grundy(0), Grundy(1), Grundy(2), Grundy(3), Grundy(4)}) = 4

通过观察，可以发现，对于大于等于2的t次方，小于2的t+1次方之间的数， 其Nimber值是 t + 1。换一个写法就是：
* Grundy(i) = int(log2(i)) + 1

同样的，还有另一个发现，假设X(i) = Grundy(1) xor Grundy(2) xor Grundy(3) ... xor Grundy(i)，即一开始有i堆石子时的结果，则：
* 若i为奇数， X(i) = 1
* 若i为偶数， X(i) = Grundy(i) xor 1

那么，对于i为奇数，很显然，把第1堆全部拿走即可。而且也很显然，这就是最少的数量了，因为不可能不拿。

对于i为偶数，怎么找要拿的最小值呢。当然，做法肯定是只能将其中的某一堆的原Nimber值a变成 a xor X(i)，所以问题在于，选哪一堆能够拿最少的数量。

我先说结论，将X(i)写成二进制数后，只保留开头的1，若得到的数为b，则选Nimber值为b的数量最小的那堆, 然后拿走最小的数量使得新的Nimber值为 b xor X(i)。

比如说X（i） = 7，写成二进制是111，只保留开头的1，得到b = 4，而Nimber值为4的数量最小的是8，然后拿走最小的数量使得新的Nimber值为3，则结果为4。

首先，肯定是要使Nimber的变化值最小，这个很容易理解吧，固定当前Nimber的情况下，变化值越小，则可能需要拿走的石子数量就越小。比如，从4变到3，肯定比从4变到2要好。

同样的，也要使当前Nimber尽可能小，在固定变化值的情况下，当前Nimber越小越好。例如，如果变化值为2，从Nimber为4变到2，肯定比Nimber从100变到98要好。

Nimber的变化值最小，那就是将X(i)开头对应位从1变成0，然后X(i)中其他为1的位从0变成1。

假设X(i)写成二进制是 1 + 跟着z1个0 + 跟着y1个1 + 跟着z2个0 + 跟着z3个1 + ...  这样的形式。

如果对应的Nimber是X(i)开头对应位从0变成1， 那么最终必然是要向前面借位减去它，但如果是从1变成0，则有可能是后面的小位做了减法不够减向它借了1位。

对于后面的1的情况，考虑其中任意一位，是从1变成0，那么最终两者相减时，此位相减结果是大于0的。

而如果是从0变成1，则它不够减，需要向前面借位，此位相减结果小于0。在固定其他位的情况下，对于b - b xor X(i)，后者会有更小的值。

因此最好的做法就是开头的1变成0，后面所有为1的位都是从0变成1。

那么，能够满足条件的最小Nimber是多少呢，正好就是只保留开头的1，后面都为0对应的数。

首先，开头这一位对应位必须为1，然后就不用然后了吧，就是其他位都为0时值最小。

然后，要拿多少石子呢，假设此值为c，则目标值为d = c xor X(i)。

如果c与d之间相差1，那没有办法，由于必须至少要拿一半，就拿Nimber值为c对应的最小数目的一半。

如果相差1以上，就拿Nimber值为c对应的最小数目 - Nimber值为d对应的最大数目。放心，这个数肯定超过c的一半，因为Nimber值为d对应的最大数目 < Nimber值为c-1对应的最小数目。

代码见[solve.php](./solve.php)