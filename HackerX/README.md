# HackerX
原题见[这里](https://www.hackerrank.com/challenges/missile-defend/problem)

敌方要向你发射导弹，每个导弹有到达时间t，和一个接收控制的频率f。

你的应对方法是，部署若干个频率发射器，在导弹到达的一瞬间，用发射器发送与其相同的频率，这样就能摧毁它。

但是，由于每个导弹的频率各不相同，你也需要相应的调节频率，这里的限制是，从频率f1调节到频率f2，需要花|f2 - f1|的时间。

例如，一枚导弹到达时间 t = 2, 频率 f = 4，而另一枚导弹  t = 3， f = 2，则用于摧毁前一枚导弹的发射器不能再用于摧毁第二枚导弹，因为调节频率需要 |2 - 4| = 2的时间，会超出第二枚导弹到达时间。 

另外，如果有多个导弹在同一时刻以同一频率到达，一个发射器发送相同频率就可以一次性摧毁它们全部，不需要多个发射器。

现给定所有导弹到达时间和对应频率，问需要的最少发射器数。

# 分析
这道题，我的第一思考方向是没有错的，但是在优化方面没有能做好。

将每个导弹看做一个点，如果拦截了某个导弹a后，还能够通过调整频率继续拦截另一个导弹b，即对于[t1, f1]和[t2, f2]，t1 <= t2，若 t2 - t1 >= |f2 - f1|， 则有一条 a->b的边。

需要的是，找出图的最小路径覆盖。即找出k条路径，使得每个点都在一条路径上，这样的k的最小值。

就是这里，我就直接拿着最小路径覆盖算法尝试解题了，没有去考虑优化，然后后面的test case都超时了。

但是，不管怎样，最小路径覆盖算法也应该先讲一讲。

首先，做一下调整，将最小路径覆盖问题转换成二分图最大匹配问题。

## 二分图最大匹配
所谓二分图，是一个无向图，图中的点可以分成两部分，F和S，而图中的每一条边，都是连接F中的一个点和S中的一个点，F中的任意两个点都没有边相连，S中的任意两个点也没有边相连，这样的图就是二分图了。

匹配呢？从所有边中选中若干条边保留，移除其他的边，而若一条留下边对应的两个点都不再与其他点相连，这样的一条边，或者说它连接的两个点，就是一个匹配。

最大匹配，自然就是要找到尽可能多的匹配。即保留尽可能多的边，同时使得每个点相连的点不超过1个。

而最小路径覆盖，怎么转换成二分图最大匹配问题呢。首先对原图中的每个点，在新图中建立两个点与之对应，假设对应关系是原图中的u对应新图中的2u和2u+1。

对于原图中的边，如果有一条u->v的边，则在新图中建立一条2u -> 2v + 1的边。这样就转换成二分图最大匹配问题了。

## 匈牙利算法
匈牙利算法就是一个找二分图最大匹配问题的算法， 它有两种表示形式，一种是矩阵形式，另一种就是图的形式。

矩阵形式，说实话，我没有去了解，因为需要建立二维矩阵，而对于这道题来说，肯定内存就超了。

关于图的形式，我觉得[这篇文章](https://www.cnblogs.com/CZiFan/p/9708746.html)讲得不错，非常感谢作者CZiFan。我一开始用的就是类似的写法，虽然超时了，但是方法肯定是正确的。

## 算法优化改进
这一部分我确实是想不到，现在回想起来还觉得特别神奇。

首先再引入一个概念（好多概念，后面还有），偏序关系。

对于集合S上的一个关系R，如果R是自反的，反对称的，和可传递的，则称R是集合S的偏序关系，S是一个偏序集。假设关系对应的符号是$%，这三种性质如下：
* 自反性。对于集合中任意元素a有， a $% a。
* 反对称性。 如果 a $% b， 且 b $% a，则 a = b。
* 传递性。 如果 a $% b， 且 b $% c，则 a $% c。

举个简单的例子，集合S是所有自然数，关系R = 整除，则R是偏序关系。因为：
* a 整除 a，满足自反性。
* 如果 a 整除 b，且 b 整除 a，则 a = b， 满足反对称性。
* 如果 a 整除 b，且 b 整除 c，则 a 整除 c， 满足传递性。

而对于我们这道题 "能够继续拦截"，就是一个偏序关系
* 拦截导弹u后，再能够继续拦截u，满足自反性。
* 如果拦截u后能继续拦截v，且拦截v后能继续拦截u，则u = v（u和v对应的到达时间及频率都相同），满足反对称性。
* 如果拦截u后能继续拦截v，且拦截v后能继续拦截w， 则拦截u后能继续拦截w，满足传递性。

然后，有了偏序关系的概念，新的概念又来了。还是假设关系对应的符号是$%
* 可比。 对于集合中的两个元素，a和b，如果有 a $% b或b $% a，则a和b是可比的。
* 链。一个链是原集合S的一个子集C，在C内任意两个元素都可比。
* 反链。跟链相对，也是一个子集，在此子集内，任意两个元素都不可比。

现在再看，题目要求的就是，将点集划分成多个链，使得链的数量最少，即“最少链划分数”。

接着，抱歉，再来两个概念，最长链和最长反链。
* 最长链。原集合S的所有链中，元素最多的，就是最长链。
* 最长反链。跟最大链相对的，元素最少的反链。

而这两个，跟要求的“最少链划分数”又有什么关系呢。那就是Dilworth 定理了。
* Dilworth定理：S是一个偏序集，则S的最少链划分数等于S的最长反链的元素个数。

要想进一步了解定理的证明过程，请自行搜索吧，这个我就不再展开讲了。

所以，到此为止，问题变成了求最长反链。也就是找出最多的点集，使得任意一个点拦截之后，都不能再拦截另外一个点。

再回过来看题目给的条件，如果对于两个点i [t(i), f(i)]和 j [t(j), f(j)]，拦截i之后可以再拦截j的话，有：
* t(i) <= t(j)
* t(j) - t(i) >= |f(j) - f(i)|

考虑到一个绝对值肯定是大于等于0的，因此第二条满足的话，肯定会满足第一条，因此可以将第一条去除了，再将第二条的绝对值两种情况展开，有：
* t(j) - t(i) >= f(j) - f(i)， 即 t(j) - f(j) >= t(i) - f(i)
* t(j) - t(i) >= f(i) - f(j),  即 t(j) + f(j) >= t(i) + f(i)

于是，转换一下原始数据，将每个点[t, f]的数据转成[t + f, t - f]。此时对新的数据进行排序，先比较t + f，从小到大，若相同，再比较 t - f，依旧从小到大。

对于排序好的数据的任意两个点 i[nt(i), nf(i)] 和 j[nt(j), nf(j)](i < j)，首先肯定有 nt(i) <= nt(j)，因为就是这样排序的。
然后，只要比较 nf(i)和nf(j)的大小，就知道此两点是否可比（拦截i后是否可再继续拦截j）了。

现在，答案就呼之欲出了。就是在排序好的数据中，找到一个最长子序列 i1, i2, i3 ... in， 其中 i1 < i2 < i3 < ... < in，使得 nt(i1) > nt(i2) > nt(i3) ... > nt(in)。

是的，最后变成了一个找最长递减子序列的问题了！

而找最长递减子序列，可以用下面的算法来解决。

首先再引入一个中间数组last，它的每一项last[i]存储的是，当前可能组成的长度为i的所有子序列中，最后一个元素可能的最大值。

听起来是不是有些绕，所以，还是拿个实例来说明吧。假设数组如下：
* [87, 100, 77, 89, 53, 96, 54, 50]

依次遍历，处理过程如下：
1. 对于第1项，87，当前只可能组成长度为1的递减子序列， 设置last[1] = 87
2. 第2项，100， 当前还是只可能组成长度为1的递减子序列，而100比87大，因此更新last[1] = 100
3. 77， 当前可以组成为2的子序列了，设置last[2] = 77
4. 89, 更新last[2] = 89，因为组成的三个长度为2的序列[87, 77],[100, 77]和[100, 89]中，最后一个元素的最大值为89.
......

最终，last数组有几个值，最长递减子序列的长度就是几。

而且，也可以看到，每一步遍历的做法是这样的：
* 对于当前遍历元素item，在last数组中查找第一个比它小的元素，若没有找到，则给last数组增加一项，否则，将item取代找到的那个元素位置。

这样，解法就完全出来了。

具体代码见[solve.php](./solve.php)