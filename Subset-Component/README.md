# Subset Component
原题见[这里](https://www.hackerrank.com/challenges/subset-component/problem)

给定一个数组，里面每个元素都是64位整数。  定义操作B(x, i) = (x >> 1) & 1，求x的第i位是否为1.  
将64位，每一位看作图中的一个点， 编号从0开始到63.  
假设两个点，编号分别为i和j， 如果数组中存在一个数k， 它的第i位和第j位同时为1， 即B(k, i) == 1 && B(k, j) == 1 则这两个点之间有一条无向边， 即i和j是直接连通的。  
题目的要求是，给定一个数组， 对于这个数组的所有子集，求连通分量的数量之和。所谓连通分量， 就是特殊的子图，在此子图中， 所有的点都是相互连通的，并且不与任何不在此子图中的点连通。   

# 分析
这个没啥说的， 就是穷举莽， 基于如下一条定理：
* 如果子集中的某两项m和n有共同的节点， 即存在 i 使得 B(m, i) == B(n, i) == 1， 则m和n中所有节点在同一个连通分量中。

在这里用递归的写法， 每一项元素都处理在子集和不在子集中两种情况， 每次处理都保存当前各连通分量对应的位， 到了最后一项数组元素时计算连通分量的总数。  
假设遍历到最后，对应的数组子集，连通分量有n个， 对应的节点数量分别是 c(0), c(1), c(2) ... c(n-1)， 则连通分量总数为 64 - (c(0) - 1) - (c(1) - 1) - ... - (c(n-1) - 1).  
以上公式可以理解为， 默认情况下， 有64个连通分量， 而如果某个连通分量中有t个节点， 则连通分量数减少(t - 1)个。 

具体代码见[solve.php](./solve.php)