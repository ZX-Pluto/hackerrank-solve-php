# Swap Permutation
原题见[这里](https://www.hackerrank.com/challenges/swappermutation/problem)

有中文，就不翻译了。

# 分析
这个题目，怎么说呢，感觉应该是困难级的题。而且解题的思路，我之前貌似没掌握？

往某个特征值方面想的话，就比较容易了，但是没有想到那方面的话，就，喵呜喵呜的，脸都苦了。

## 相邻交换
对于相邻交换，关键的特征值是“逆序对”的数量。

所谓逆序对，就是对于两个元素i < j，如果在最终数组中，j的位置出现在i的前面，则构成一个逆序对。

进行相邻交换，则只有被交换的这两个元素之间是否逆序发生改变，它们与其他元素之间的逆序关系保持不变。换句话说，每次交换，逆序对数量的改变值是+1或-1。

同时，出于奇偶性的考虑，交换k次，可能构成的逆序对数是k, k-2, k-4, k-6, k-8 ... 。如果k是偶数，最小为0，如果k是奇数，最小为1。

那么就按逆序对的数量来进行动态规划好了。假设d(i, j)表示前i+1个元素（数组下标从0开始）构成j个逆序对的不同排列的数量。则有：
* d(i+1, j) = d(i, j) + d(i, j-1) + d(i, j-2) + d(i, j-3) + ... + d(i, 0)

可以这样来想，假设前i+1个元素已经摆放好了，现在要将第i+2个元素也放进来，那么，有i+2种放法，分别是放在第1个之前，第1个和第2个之间，第2个和第3个之间，第3个和第4个之间... 第i个和第i+1个之前，第i+1个之后。

每种放法，分别对应增加i+1个逆序，增加i个逆序，增加i-1个逆序... 增加2个逆序，增加1个逆序，增加0个逆序。

反转过来，就是上面的公式了，即若现在i+2个元素，共j个逆序，则可以前i+1个元素共j个逆序，第i+2个元素放最后，前i+1个元素共j-1个逆序，第i+2个元素放倒数第二的位置，依此类推。

但是要注意一点，放第i+2个元素时，最多也只能增加i+1个逆序，所以实际可以没有办法加到d(i, 0)，最多加到d(i, max(0, j - (i+1)))为止。

但是，如果这样for循环计算，时间复杂度会超，所以需要用累加计算的方式。也就是若：
* d(i, j) = d(i-1, j) + d(i-1, j-1) + d(i-1, j-2) + d(i-1, j-3) + ... + d(i-1, max(0, j - i))
* d(i, j-1) = d(i-1, j-1) + d(i-1, j-2) + d(i-1, j-3) + d(i-1, j-4) + ... + d(i-1, max(0, j - 1 - i))

则若 j - 1 - i >= 0，即 j >= i + 1时，有 d(i, j) - d(i, j -1) = d(i-1, j) - d(i-1, j-1-i)。

j < i + 1时，有  d(i, j) - d(i, j -1) = d(i-1, j)。

根据此公式累加求和即可。

至于初始化的值，则是：
* d(i, 0) = 1， 当 i >= 0，意味着如果没有逆序，则只有一种排列方式。
* d(0, j) = 0, 当 j > 0，意思是，只有一个元素时，不可能构成逆序。

## 任意交换
任意交换，比上面的要莽，d(i, j)就表示前i+1个元素进行j次交换构成的不同排列的数量。有：
d(i, j) = (i - 1) * d(i - 1, j - 1) + d(i - 1, j) 

即第i个元素要么不交换，要么跟前面任一元素进行交换。

这里可能你会想，第i个元素我也是可以换来换去，不是最后才交换一次的啊，但实际最后的结果，可以等价于它与最终位置所在的元素进行交换。

代码见[solve.php](./solve.php)