# Substring Diff
原题见[这里](https://www.hackerrank.com/challenges/substring-diff/problem)

这个问题，我们会对“最长公共子串”做一个松弛，它的意思是，对两个长度相同的子串，挨个字符比较，允许一定数量的位置字符不相同。

例如，'abc'和'adc'有1个位置不相同，'aab'与'aba'有2个位置字符不相同。

给定两个字符串和数字k，计算这两个字符串松弛的最长公共子串的最大长度，即两个子串允许有k个位置字符不相同。

例如，对于s1 = 'abcd', s2 = 'bbca', k = 1，应该返回3， 因为可以从s1中选择'abc'，从s2中选择'bbc'，它们仅有1个位置字符不相同。

# 分析
假设找到了两个满足松弛条件的子串a和b，其中a在s1中的起始位置为i， b在s2中的起始位置为j。

首先，来考虑i = j的情况，即它们都是从同一位置开始的。有什么办法获得这种情况的最长的子串呢？

办法是，使用数组记录从开头开始，到每个位置作为结束的子串，有多少个位置字符不同。

假设此数组为a，则以上面的'abcd'和'bbca'为例， a[0] = 1, a[1] = 1, a[2] = 1, a[3] = 2。

则最长的满足条件的子串，就是如下两种情况的较大者：
* 最大的满足a[i] <= k的i， 从开头到i为止的子串。
* 对于每个j > k， 最大的满足a[m] = j的m和最小的a[n] = j-k的n，n + 1到m之间的子串。

第一种情况，就是 i = 2, 从头开始，到位置2结束，即'abc'和'bbc'。

第二种情况， 对于j = 2， 最大的a[3] = 2, 最小的a[0] = 2 - 1， 就是 0 + 1到3之间的子串，即'bcd'和'bca'。

但这样话就得用查找了，那么，如果反过来记呢？

用数组b记录有t个字符不同的首个位置，这样如果当前位置有s个字符不同，则以当前位置为结尾的满足条件的最长子串就是从b[s-k]的下个位置开始到此位置结束。

即b[0] = -1, b[1] = 1, b[2] = 3。 则满足条件的最长长度就是以下两种情况的最大者：
* 若当前位置x有i个字符不同，且 i <= k，则为最大的x - b[0]
* 若当前位置x有i个字符不同，且 i > k，则为最大的 x - b[i-k]的最大值。

同样的，若a在s1中的起始位置为i， b在s2中的起始位置为j，依次遍历i = 0和j = 1,2, ...和 j = 1, i = 1, 2, ...的每种情况即可。

代码见[solve.php](./solve.php)