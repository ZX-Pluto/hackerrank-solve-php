# Super Functional Strings
原题见[这里](https://www.hackerrank.com/challenges/super-functional-strings/problem)

给定了一个函数，对于一个字符串P， F(P) = (a的b次方) % 1000000007，其中a为P的长度，b为P中不同字符的个数。

要求给定一个字符串S，全由小写字母组成。求所有不同子串的F函数之和。

# 分析
根据题意，现在面临了两个问题， 一个是求字符串的不同子串，另一个是求F函数之和。那么，我们就分成两步讨论，第一步，讨论如果计算所有子串F函数之和，第二步，如何求不同的子串，并与第一步计算结合起来，得到最终结果。

## 计算F函数之和
首先，由题目可知，要计算的字符串长度，最长为100000，与此同时，由于都是小写字母，由于不同字符的个数最多为26。
那么我们有了很暴力的第一步处理：将这2600000个结果全部计算出来，缓存起来，之后需要哪个结果，就直接从缓存中取，无需再重复计算。

接下来考虑进一步的优化。首先引入“后缀子串”的概念，对于一个字符串S，后缀字符串就是由其任一位置开始，直到S末尾，这部分子串。

例如，对于字符串abcdef, 它有6个不同的后缀子串，分别是f, ef, def, cdef, bcdef, abcdef。

很显然（这次是真的很显然），长度为k的字符串，有k个不同的后缀子串，分别由最后1个，最后2个，最后3个...最后k个字符构成。
换个方向看，也就是从第0个字符开始直到结尾，第1个字符开始直到结尾，第2个字符开始直到结尾...第k-1个字符开始直到结尾。


那么，后缀子串跟计算F函数有什么关系呢？对于S的任意一个子串T，假设从第t1个字符开始，到第t2个字符（包括t2）结束，它必然是从t1开始的后缀子串的长度为(t2 - t1 + 1)的前缀。其中前缀就是跟后缀对应的，从首个字符开始的子串。

则问题可以转化为：对于每个后缀子串，求其全部前缀子串的F函数之和，再将这些再求和。

接下来，“由于都是小写字母”就有用了。考虑第i个字符，可以记录原串S中大于等于i的所有位置中，每个小写字母第一次出现的位置，则任意两个相邻的出现位置之间，不同字符的个数是相同的。下面举例说明：

假设字符串为 aaabbbcccddddeefff，总长度为18，以i = 4，即第2个b所在的位置为例。
* 第一次出现b的位置，4
* 第一次出现c的位置，6
* 第一次出现d的位置，9
* 第一次出现e的位置，13
* 第一次出现f的位置，15

再考虑以 i = 4开始的后缀字符串bbcccdddeeefff的全部前缀。
* b, 长度为1， 不同字符数为1
* bb, 长度为2， 不同字符数为1
* bbc， 长度为3， 不同字符数为2
* bbcc， 长度为4， 不同字符数为2
* bbccc， 长度为5， 不同字符数为2
* bbcccd， 长度为6， 不同字符数为3
* bbcccdd， 长度为7， 不同字符数为3
* bbcccddd， 长度为8， 不同字符数为3
* bbcccdddd， 长度为9， 不同字符数为3
* bbcccdddde， 长度为10， 不同字符数为4
* bbcccddddee， 长度为11， 不同字符数为4
* bbcccddddeef， 长度为12， 不同字符数为5
* bbcccddddeeff， 长度为13， 不同字符数为5
* bbcccddddeefff， 长度为14， 不同字符数为5

可以看到，如果按照从短到长的顺序遍历所有前缀，每次遍历，长度+1。同时，当且仅当有新的字母第一次出现时，不同字符个数+1。

假设当前项长度为 t, 当前不同字符数为 s， 要在w个字符之后才出现新的字母，则长度为t到t + w - 1这部分的和为
* F(t, s) + F(t+1, s) + ... + F(t+w-2, s) + F(t+w-1, s)

新增一个函数G(i, j) = F(1, j) + F(2, j) + F(3, j) + ... + F(i, j)，即从长度1开始到长度i为止，出现j个不同字母的值的累加。则上面的部分和可以写成
* G(t+w-1, s) - G(t-1, s)

而全部前缀的F之和，是可以拆成多个部分和的，也就是可以用两个G函数之差来表示。因此，将缓存的项变化一下，不缓存F函数的结果，而是G函数的结果。

同时，对于原串S的每个位置i，记录原串S中大于等于i的所有位置中，每个小写字母第一次出现的位置，两者结合，就可以计算出全部子串的F函数之和。

这部分示例代码见[demof.php](./demof.php)

## 求不同的子串
最终题意要求的结果怎么求呢？当然是在计算F函数之和时，重复的子串，只计算一次，就是结果了。那么有什么数据结构或算法帮我们找出重复子串呢？有，那就是后缀数组 + 最长公共前缀。

你问我为什么会想到用这个？抱歉，我也想不到，但是我们现在都站在巨人肩膀上，巨人发现用这个可以求，而我不小心知道了。就类似于求 1+2+3+4...+100，我自己也想不到用等差数列求和公式，但是有伟大的数学家研究出了这个，我们记住就好了。

是的，看见等差数列求和，就用求和公式。看见要找一个字符串的不同子串，就用后缀数组。有时候，还是得记下来用什么方式解决。

后缀数组，当然就是由全部后缀子串组成的数组，但是，有一点很重要，它是排好序的，按照字符串比较的方式进行排序。还有，因为是后缀，因此数组每一项，并不需要记录整个子串，记录对应的开始位置就好了。

这里进行排序，要使用一种倍增比较的算法。 你又问我为什么能想到？ 那平时数组排序是怎么想到用快速排序呢？还是类似上面的话，“我自己想不到，但是有人研究出了这个，我又碰巧知道了这是可行的”。

### 倍增算法
倍增算法的思想是，排序多轮，每轮只比较每个字符串的最前若干个字符，这个“若干”随排序的轮次递增。也就是：
* 第一轮排序，拿前1个字符比较。
* 第二轮排序，拿前2个字符比较。
* 第三轮排序，拿前4个字符比较。
* 第四轮排序，拿前8个字符比较。
......
* 第k轮排序，拿前 2的(k-1)次方个字符比较。

字符串长度不够怎么办，定义一个字符，令其比所有可能出现的字符都小，然后假设空白的位置都放着一个此字符即可。长度为n的字符串，最多进行log(n)次排序即可。

下面是关键了。排序的时候，并不是真的要去比字符串，而是用一个自定义的次序号来进行迭代。每一轮排序结束后，对于已排序数组，都会重新生成次序号，生成的方式如下：
1. 假设初始次序号t = 0, 将第1项的次序号设为t,t++。
2. 第从2项开始，每次都与前1项比较，若相等，则设为前1项的次序号，否则，将其次序号设为t， t++。

而下次比较的时候，也是用次序号。假设现在完成了第i轮排序，并生成了次序号， 其代表的是 前 2^(i-1)个字符的大小。

第i+1轮排序，要比较2^i个字符的大小，可以将其拆成两部分，前2^(i-1)个字符，和后2^(i-1)个字符， 然后先比较前一部分，再比较后一部分就好了。而这两部分，正好用上了上一轮生成的次序号。

对于任一位置p，前2^(i-1)个字符的次序号就是上一轮生成的次序号，而后2^(i-1)个字符的次序号，就是起始位置为(p + 2^(i-1))的位置对应的上轮次序号。这样每轮就可以迭代比较生成下去了。

而且，比较的时候，还有一点可以优化，如果某一轮，每项的次序号都不同，意味着已经排好序，可以结束了。

但是，你可能还有两个问题：
1. 第一轮排序，还没有生成次序号，这时怎么办？ 有两种办法，一是直接拿字符比，二是在此之前，先生成次序号，用第1个字符的ascii码进行处理，使最小值为0。
2. 计算次序号的时候，如果p + 2^(i-1)超出了数组长度怎么办？ 对于超出了的，次序号都设为-1，这样就跟前面的“空白的位置都放着一个此字符”保持一致了。

而每轮排序的处理，先用系统提供的排序好了，当然，用基数排序能够有更好的时间复杂度，我给的demo中也有，但是注释掉了，有兴趣可以自己看看。

示例代码见[demos.php](./demos.php)

### 求后缀数组相邻两项的最长公共前缀
上一步排序，求出了后缀数组，接下来需要进一步求此数组中相邻两项的最长公共前缀，这就是去重的关键了。

任何子串，都是后缀数组中某一项的前缀，所以任何重复的子串也是。而由于是重复的子串，必然是后缀数组中某相邻两项的最长公共前缀的前缀。举个例子来说明吧。

假设字符串是abcabd.可求出后缀数组为：
* abcabd
* abd
* bcabd
* bd
* cabd
* d

可以看到，对于重复的子串'a'，是'abcabd'和'abd'的最长公共前缀'ab'的前缀。

因此，计算子串的时候，对于后缀数组中的每项，与前一项的最长公共前缀及其所有前缀，不再计算，这样就达到了去重的目的。

求最长公共前缀，有[kasai算法](http://web.cs.iastate.edu/~cs548/references/linear_lcp.pdf)。但或许你懒得看完原文，因为我自己也没全部看，就看了实现的部分。

主要的思想就是用迭代计算。从在原字符串中起点序号为0的后缀开始，然后是起点为1的后缀，起点为2...起点为n-1，依次计算。主要根据如下一条性质：
* 如果起点为i的后缀，计算出在后缀数组中与前一项的最长公共前缀长度为n，则起点为i+1的后缀，其与前一项的最长公共前缀长度至少为n-1。

可以比较直观的想一下，求出的这个长度为n的公共前缀，是起点为i的和起点为j的。则去掉第一个字符，则依然是起点为i+1的后缀与起点为j+1的后缀的公共前缀，因此i+1的后缀与前一项的最长公共前缀长度至少为n-1。

这个就不单独给demo了，看最终具体代码中对应的`buildLCPWithKasai`函数吧。

## 求题目要求的结果
现在我们有了后缀数组和最长公共前缀。求和过程如下：
1. 对于后缀数组的第1项，求所有前缀的F函数之和。
2. 对于后缀数组的其他项，求所有前缀长度大于“与前一项的最长公共前缀长度”的F函数之和。

具体代码见[solve.php](./solve.php)